'use client'

import React, { useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { MonthPicker } from '@/components/ui/month-picker'
import { FileSpreadsheet, FileText, Calendar } from 'lucide-react'
import { useUserRole } from '@/hooks/useUserRole'
import { RoleGuard } from '@/components/auth/RoleGuard'
import { useRouter } from 'next/navigation'
import { useSelectedRole } from '@/contexts/SelectedRoleContext'
import { useSearchParams } from 'next/navigation'
import { Input } from '@/components/ui/input'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Building2, Search } from 'lucide-react'
import { toast } from '@/lib/toast'
import { toLocalDateString } from '@/lib/utils/dateUtils'
import {
  getExcelHeaderStyle,
  getExcelCellStyle,
  getExcelAlternateRowStyle,
  getExcelTotalStyle,
  getPDFHeaderStyles,
  getPDFBodyStyles,
  getPDFAlternateRowStyles,
  getPDFTotalRowColor,
  getPDFCellTextColor,
} from '@/lib/utils/exportStyles'
import { getAvailableTableWidth, getProportionalColumnStyles, type PDFTableColumnConfig } from '@/lib/utils/pdfTableUtils'

interface ReporteMensualProps {
  fcpId: string | null
}

interface NivelData {
  nivel: string
  tutor?: string // Nombre del tutor del aula/nivel
  asistenPromed: number // Suma de asistencias "presente" en el mes
  registrados: number // Total de estudiantes activos en el nivel
  porcentaje: number // (asistenPromed / registrados) * 100
}

interface DiaIncompleto {
  fecha: string
  fechaFormateada: string
  nivel: string
  aulaId: string
  marcados: number
  total: number
}

interface ReporteData {
  fcp: { id: string; razon_social: string; numero_identificacion?: string }
  year: number
  month: number
  niveles: NivelData[]
  totalAsistenPromed: number
  totalRegistrados: number
  totalPorcentaje: number
  diasIncompletos: DiaIncompleto[]
}

export function ReporteMensual({ fcpId: fcpIdProp }: ReporteMensualProps) {
  const searchParams = useSearchParams()
  const autoGenerate = searchParams.get('auto') === 'true'
  const yearParam = searchParams.get('year')
  const monthParam = searchParams.get('month')
  
  const [loading, setLoading] = useState(false)
  const [selectedYear, setSelectedYear] = useState(
    yearParam ? parseInt(yearParam) : new Date().getFullYear()
  )
  const [selectedMonth, setSelectedMonth] = useState(
    monthParam ? parseInt(monthParam) - 1 : new Date().getMonth()
  )
  const [selectedFCP, setSelectedFCP] = useState<string | null>(fcpIdProp || null)
  const [userFCPs, setUserFCPs] = useState<Array<{ id: string; nombre: string; numero_identificacion?: string; razon_social?: string }>>([])
  const [reporteData, setReporteData] = useState<ReporteData | null>(null)
  const [facilitadorNombre, setFacilitadorNombre] = useState<string>('')
  const [responsable, setResponsable] = useState<{ nombre: string; email: string; rol: string } | null>(null)
  const [isFacilitador, setIsFacilitador] = useState(false)
  const [autoGenerated, setAutoGenerated] = useState(false)
  const [isMobile, setIsMobile] = useState(false)
  const [mobileSearch, setMobileSearch] = useState('')
  const [mobilePage, setMobilePage] = useState(1)
  const { canViewReports, loading: roleLoading, role } = useUserRole(selectedFCP)
  const router = useRouter()
  const { selectedRole } = useSelectedRole()

  useEffect(() => {
    const check = () => setIsMobile(window.innerWidth < 640)
    check()
    window.addEventListener('resize', check)
    return () => window.removeEventListener('resize', check)
  }, [])

  useEffect(() => {
    setMobilePage(1)
    setMobileSearch('')
  }, [reporteData])

  useEffect(() => {
    const initialize = async () => {
      await checkIfFacilitador()
      if (fcpIdProp) {
        setSelectedFCP(fcpIdProp)
      }
      await loadUserFCPs()
    }
    initialize()
  }, [fcpIdProp, selectedRole?.role, selectedRole?.fcpId])

  // Generar reporte autom√°ticamente cuando viene desde "Ver Reporte" del dashboard
  useEffect(() => {
    if (autoGenerate && !roleLoading && !autoGenerated && !loading && !reporteData && selectedFCP) {
      // Peque√±o delay para asegurar que todo est√© listo
      const timer = setTimeout(() => {
        setAutoGenerated(true)
        generarReporte()
      }, 500)
      return () => clearTimeout(timer)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoGenerate, roleLoading, autoGenerated, loading, reporteData, selectedFCP])

  const checkIfFacilitador = async () => {
    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data: facRow } = await supabase
        .from('facilitadores')
        .select('usuario_id')
        .eq('usuario_id', user.id)
        .maybeSingle()

      setIsFacilitador(!!facRow)
    } catch (error) {
      console.error('Error checking facilitador:', error)
    }
  }

  const loadUserFCPs = async () => {
    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data: facRow } = await supabase.from('facilitadores').select('usuario_id').eq('usuario_id', user.id).maybeSingle()
      const isFacilitadorCheck = !!facRow
      setIsFacilitador(isFacilitadorCheck)

      let fcps: Array<{ id: string; nombre: string; numero_identificacion?: string; razon_social?: string }> = []

      if (isFacilitadorCheck) {
        const { data: fcpsData, error: fcpsError } = await supabase
          .from('fcps')
          .select('id, razon_social, numero_identificacion')
          .eq('facilitador_id', user.id)
          .eq('activa', true)
          .order('razon_social', { ascending: true })
        if (fcpsError) throw fcpsError
        fcps = (fcpsData || []).map((fcp: any) => ({
          id: fcp.id,
          nombre: fcp.razon_social || 'FCP',
          numero_identificacion: fcp.numero_identificacion,
          razon_social: fcp.razon_social,
        }))
      } else {
        const { data, error } = await supabase
          .from('fcp_miembros')
          .select('fcp_id, fcp:fcps(id, razon_social, numero_identificacion)')
          .eq('usuario_id', user.id)
          .eq('activo', true)
          .not('fcp_id', 'is', null)
        if (error) throw error
        fcps = data?.map((item: any) => ({
          id: item.fcp.id,
          nombre: item.fcp.razon_social || item.fcp.numero_identificacion || 'FCP',
          numero_identificacion: item.fcp.numero_identificacion,
          razon_social: item.fcp.razon_social,
        })) || []
      }

      if (selectedRole?.fcpId) {
        const sole = fcps.find((f: any) => f.id === selectedRole.fcpId)
        fcps = sole ? [sole] : []
      }

      setUserFCPs(fcps)
      if (fcps.length > 0 && !selectedFCP && !isFacilitadorCheck && !fcpIdProp) {
        if (selectedRole?.fcpId && fcps.some((f: any) => f.id === selectedRole.fcpId)) setSelectedFCP(selectedRole.fcpId)
        else setSelectedFCP(fcps[0].id)
      }
    } catch (error) {
      console.error('Error loading FCPs:', error)
    }
  }

  const loadFacilitador = async (fcpId: string) => {
    try {
      const supabase = createClient()
      const { data: fcpRow } = await supabase
        .from('fcps')
        .select('facilitador_id')
        .eq('id', fcpId)
        .single()
      if (!fcpRow?.facilitador_id) {
        setFacilitadorNombre('')
        return
      }
      const { data: usuario } = await supabase
        .from('usuarios')
        .select('nombre_completo, email')
        .eq('id', fcpRow.facilitador_id)
        .maybeSingle()
      const nombre = usuario?.nombre_completo || usuario?.email || ''
      setFacilitadorNombre(nombre)
    } catch (error) {
      console.error('Error loading facilitador:', error)
      setFacilitadorNombre('')
    }
  }

  const generarReporte = async () => {
    // Usar el fcpId del rol seleccionado si est√° disponible, de lo contrario usar selectedFCP
    const fcpIdParaReporte = selectedRole?.fcpId || selectedFCP
    
    if (!fcpIdParaReporte) {
      toast.warning('Selecciona FCP o rol', 'Selecciona una FCP o aseg√∫rate de tener un rol seleccionado.')
      return
    }

    console.log('üìä [ReporteMensual] Generando reporte con:', {
      fcpIdParaReporte,
      selectedFCP,
      selectedRoleFcpId: selectedRole?.fcpId,
      selectedRole: selectedRole?.role
    })

    try {
      setLoading(true)
      const supabase = createClient()

      // Obtener datos del usuario actual (responsable) usando el rol seleccionado
      const { data: { user } } = await supabase.auth.getUser()
      if (user && selectedRole) {
        // Usar el rol seleccionado del contexto
        const rolSeleccionado = selectedRole.role
        
        // Obtener datos del usuario desde la tabla usuarios
        const { data: usuarioData, error: usuarioError } = await supabase
          .from('usuarios')
          .select('nombre_completo, email')
          .eq('id', user.id)
          .single()

        // Si no est√° en usuarios, obtener desde auth.users metadata
        let nombreCompleto = usuarioData?.nombre_completo || user.user_metadata?.full_name || user.user_metadata?.name || ''
        let emailUsuario = usuarioData?.email || user.email || ''

        // Mapear el rol a formato legible
        const rolFormateado = rolSeleccionado === 'facilitador' ? 'Facilitador' 
          : rolSeleccionado === 'director' ? 'Director' 
          : rolSeleccionado === 'secretario' ? 'Secretario' 
          : rolSeleccionado === 'tutor' ? 'Tutor' 
          : rolSeleccionado.charAt(0).toUpperCase() + rolSeleccionado.slice(1)

        console.log('üë§ [ReporteMensual] Estableciendo responsable:', {
          rolSeleccionado,
          rolFormateado,
          nombreCompleto,
          emailUsuario,
          selectedRole
        })

        setResponsable({
          nombre: nombreCompleto || emailUsuario || 'Usuario',
          email: emailUsuario,
          rol: rolFormateado,
        })
      } else if (user && !selectedRole) {
        const { data: facRow } = await supabase.from('facilitadores').select('usuario_id').eq('usuario_id', user.id).maybeSingle()
        const { data: fcpRow } = await supabase.from('fcps').select('id').eq('id', fcpIdParaReporte).eq('facilitador_id', user.id).maybeSingle()
        if (facRow && fcpRow) {
          const { data: u } = await supabase.from('usuarios').select('nombre_completo, email').eq('id', user.id).maybeSingle()
          setResponsable({
            nombre: u?.nombre_completo || (user as any).email || '',
            email: u?.email || (user as any).email || '',
            rol: 'Facilitador',
          })
        } else {
          const { data: usuarioFcpData, error: usuarioFcpError } = await supabase
            .from('fcp_miembros')
            .select('rol, usuario:usuarios(nombre_completo, email)')
            .eq('usuario_id', user.id)
            .eq('fcp_id', fcpIdParaReporte)
            .eq('activo', true)
            .limit(1)
          if (!usuarioFcpError && usuarioFcpData?.length) {
            const usuarioFcp = usuarioFcpData[0]
            const usuario = usuarioFcp.usuario as any
            const rol = usuarioFcp.rol === 'director' ? 'Director' : usuarioFcp.rol === 'secretario' ? 'Secretario' : usuarioFcp.rol === 'tutor' ? 'Tutor' : ''
            if (rol) setResponsable({ nombre: usuario?.nombre_completo || usuario?.email || user.email || '', email: usuario?.email || user.email || '', rol })
          }
        }
      }

      // Obtener datos de la FCP usando el fcpId del rol seleccionado
      const { data: fcpData, error: fcpError } = await supabase
        .from('fcps')
        .select('id, razon_social, numero_identificacion')
        .eq('id', fcpIdParaReporte)
        .single()

      if (fcpError) {
        console.error('‚ùå [ReporteMensual] Error obteniendo FCP:', fcpError)
        throw fcpError
      }

      // Calcular fechas del mes (fecha local para no incluir d√≠a del mes siguiente por UTC)
      const fechaInicio = new Date(selectedYear, selectedMonth, 1)
      const fechaFin = new Date(selectedYear, selectedMonth + 1, 0)
      const fechaInicioStr = toLocalDateString(fechaInicio)
      const fechaFinStr = toLocalDateString(fechaFin)

      // Determinar si estamos consultando un mes anterior
      const fechaActual = new Date()
      const mesActual = new Date(fechaActual.getFullYear(), fechaActual.getMonth(), 1)
      const mesConsultado = new Date(selectedYear, selectedMonth, 1)
      const esMesAnterior = mesConsultado < mesActual

      console.log('üìÖ [ReporteMensual] Mes consultado:', {
        mesConsultado: `${selectedYear}-${selectedMonth + 1}`,
        mesActual: `${fechaActual.getFullYear()}-${fechaActual.getMonth() + 1}`,
        esMesAnterior
      })

      // Cargar facilitador
      await loadFacilitador(fcpIdParaReporte)

      // Obtener TODAS las asistencias del mes (para detectar d√≠as incompletos)
      // IMPORTANTE: Incluir aula_id de la asistencia para preservar el aula hist√≥rica
      const { data: todasAsistenciasData, error: todasAsistenciasError } = await supabase
        .from('asistencias')
        .select(`
          estudiante_id, 
          fecha, 
          estado,
          aula_id,
          aula:aulas(id, nombre),
          estudiante:estudiantes(id, aula_id, created_at)
        `)
        .eq('fcp_id', fcpIdParaReporte)
        .gte('fecha', fechaInicioStr)
        .lte('fecha', fechaFinStr)

      if (todasAsistenciasError) {
        console.error('‚ùå [ReporteMensual] Error obteniendo asistencias:', todasAsistenciasError)
        throw todasAsistenciasError
      }

      // Obtener estudiantes seg√∫n el mes consultado
      let estudiantesData: any[] = []

      if (esMesAnterior) {
        // Para meses anteriores, obtener estudiantes √∫nicos de las asistencias
        const estudiantesMap = new Map<string, any>()
        todasAsistenciasData?.forEach((asist: any) => {
          if (asist.estudiante && !estudiantesMap.has(asist.estudiante_id)) {
            estudiantesMap.set(asist.estudiante_id, {
              id: asist.estudiante.id,
              aula_id: asist.aula_id, // Usar aula_id de la asistencia (hist√≥rica)
              created_at: asist.estudiante.created_at
            })
          }
        })
        estudiantesData = Array.from(estudiantesMap.values())
        
        console.log('üìä [ReporteMensual] Estudiantes cargados de mes anterior (basados en asistencias):', {
          total: estudiantesData.length
        })
      } else {
        // Para meses actuales/futuros, cargar todos los estudiantes activos de la FCP
        const { data: estudiantesDataQuery, error: estudiantesError } = await supabase
          .from('estudiantes')
          .select('id, aula_id, created_at')
          .eq('fcp_id', fcpIdParaReporte)
          .eq('activo', true)

        if (estudiantesError) {
          console.error('‚ùå [ReporteMensual] Error obteniendo estudiantes:', estudiantesError)
          throw estudiantesError
        }

        estudiantesData = estudiantesDataQuery || []
        
        console.log('üìä [ReporteMensual] Estudiantes cargados (mes actual/futuro):', {
          total: estudiantesData.length
        })
      }

      // Obtener aulas seg√∫n el mes consultado
      let aulasData: any[] = []

      if (esMesAnterior) {
        // Para meses anteriores, obtener aulas √∫nicas de las asistencias
        const aulasMap = new Map<string, any>()
        todasAsistenciasData?.forEach((asist: any) => {
          if (asist.aula_id && asist.aula && !aulasMap.has(asist.aula_id)) {
            aulasMap.set(asist.aula_id, {
              id: asist.aula_id,
              nombre: asist.aula.nombre || 'Sin aula'
            })
          }
        })
        aulasData = Array.from(aulasMap.values()).sort((a, b) => a.nombre.localeCompare(b.nombre))
        
        console.log('üè´ [ReporteMensual] Aulas cargadas de mes anterior (basadas en asistencias):', {
          total: aulasData.length
        })
      } else {
        // Para meses actuales/futuros, cargar todas las aulas activas de la FCP
        const { data: aulasDataQuery, error: aulasError } = await supabase
          .from('aulas')
          .select('id, nombre')
          .eq('fcp_id', fcpIdParaReporte)
          .eq('activa', true)
          .order('nombre', { ascending: true })

        if (aulasError) {
          console.error('‚ùå [ReporteMensual] Error obteniendo aulas:', aulasError)
          throw aulasError
        }

        aulasData = aulasDataQuery || []
        
        console.log('üè´ [ReporteMensual] Aulas cargadas (mes actual/futuro):', {
          total: aulasData.length
        })
      }

      if (todasAsistenciasError) {
        console.error('‚ùå [ReporteMensual] Error obteniendo asistencias:', todasAsistenciasError)
        throw todasAsistenciasError
      }

      // Cargar tutores de las aulas para el reporte
      const aulaIds = aulasData?.map((a: any) => a.id) || []
      const aulaTutorMap = new Map<string, string>()
      if (aulaIds.length > 0) {
        const { data: tutorAulasData } = await supabase
          .from('tutor_aula')
          .select(`
            aula_id,
            fcp_miembro:fcp_miembros(
              nombre_display,
              email_pendiente,
              usuario:usuarios(nombre_completo, email)
            )
          `)
          .eq('fcp_id', fcpIdParaReporte)
          .eq('activo', true)
          .in('aula_id', aulaIds)
        tutorAulasData?.forEach((ta: any) => {
          const fm = ta.fcp_miembro
          if (!fm) return
          const usuario = fm.usuario
          const tutorNombre = (fm.nombre_display?.trim() || usuario?.nombre_completo?.trim() || usuario?.email || fm.email_pendiente) || 'Sin tutor asignado'
          aulaTutorMap.set(ta.aula_id, tutorNombre)
        })
      }

      // Obtener asistencias "presente" para el c√°lculo del reporte
      const asistenciasPresente = todasAsistenciasData?.filter(a => a.estado === 'presente') || []

      // Calcular datos por nivel y detectar d√≠as incompletos
      const niveles: NivelData[] = []
      let totalAsistenPromed = 0
      let totalRegistrados = 0
      let totalOportunidadesAsistencia = 0
      const diasIncompletosGlobales: DiaIncompleto[] = []

      aulasData?.forEach((aula) => {
        // IMPORTANTE: Agrupar estudiantes por aula seg√∫n el mes consultado
        // Para meses anteriores: usar aula_id de las asistencias (hist√≥rica)
        // Para meses actuales/futuros: usar aula_id actual del estudiante
        let estudiantesAula: any[] = []
        
        if (esMesAnterior) {
          // Para meses anteriores, filtrar asistencias que pertenecen a esta aula seg√∫n aula_id de la asistencia
          const asistenciasDeAula = todasAsistenciasData?.filter((a: any) => a.aula_id === aula.id) || []
          const estudiantesIdsEnAula = new Set(asistenciasDeAula.map((a: any) => a.estudiante_id))
          estudiantesAula = estudiantesData?.filter(e => estudiantesIdsEnAula.has(e.id)) || []
        } else {
          // Para meses actuales/futuros, filtrar estudiantes por su aula_id actual
          estudiantesAula = estudiantesData?.filter(e => e.aula_id === aula.id) || []
        }
        
        const registrados = estudiantesAula.length
        
        // IMPORTANTE: Usar aula_id de la asistencia para filtrar asistencias correctamente
        const asistenciasDeAula = todasAsistenciasData?.filter((a: any) => a.aula_id === aula.id) || []

        // Detectar d√≠as incompletos para esta aula usando aula_id de la asistencia
        const estudiantesAulaIds = new Set(estudiantesAula.map(e => e.id))
        const asistenciasPorFecha = new Map<string, Set<string>>() // fecha -> Set<estudiante_id>

        asistenciasDeAula.forEach((asistencia: any) => {
          if (estudiantesAulaIds.has(asistencia.estudiante_id)) {
            const fecha = asistencia.fecha
            if (!asistenciasPorFecha.has(fecha)) {
              asistenciasPorFecha.set(fecha, new Set())
            }
            // Agregar el estudiante si tiene asistencia registrada (cualquier estado: presente, falt√≥, permiso)
            asistenciasPorFecha.get(fecha)!.add(asistencia.estudiante_id)
          }
        })
        
        // Log detallado para depuraci√≥n (solo para el primer d√≠a del mes para no saturar)
        if (aula.id === aulasData?.[0]?.id) {
          const primerDia = `${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}-01`
          const asistenciasPrimerDia = asistenciasPorFecha.get(primerDia) || new Set()
          console.log('üìä [ReporteMensual] Verificaci√≥n detallada para aula:', {
            aula: aula.nombre,
            totalEstudiantes: registrados,
            primerDia,
            estudiantesConAsistenciaPrimerDia: asistenciasPrimerDia.size,
            estudiantesIds: Array.from(estudiantesAulaIds).slice(0, 10),
            estudiantesConAsistenciaIds: Array.from(asistenciasPrimerDia).slice(0, 10)
          })
        }

        // D√≠as completos: solo cuenta un d√≠a cuando TODOS los estudiantes tienen registro
        // (presente, falt√≥ o permiso). Si alg√∫n estudiante no tiene estado ese d√≠a, no cuenta.
        let diasDeClases = 0
        let totalAsistenciasPresente = 0
        const todasAsistenciasPorEstudianteFecha: { [key: string]: string } = {}
        asistenciasDeAula.forEach((asistencia: any) => {
          if (estudiantesAulaIds.has(asistencia.estudiante_id)) {
            const key = `${asistencia.estudiante_id}-${asistencia.fecha}`
            todasAsistenciasPorEstudianteFecha[key] = asistencia.estado
          }
        })

        // Verificar cada fecha del mes para detectar d√≠as incompletos
        // Generar todas las fechas del mes seleccionado
        const diasDelMes = new Date(selectedYear, selectedMonth + 1, 0).getDate()
        
        for (let dia = 1; dia <= diasDelMes; dia++) {
          const fechaDate = new Date(selectedYear, selectedMonth, dia)
          const fechaStr = `${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}-${String(dia).padStart(2, '0')}`
          
          // Contar cu√°ntos estudiantes tienen asistencia registrada en esta fecha
          const estudiantesConAsistencia = asistenciasPorFecha.get(fechaStr) || new Set()
          const marcados = estudiantesConAsistencia.size
          
          // Para detectar d√≠as incompletos, usar TODOS los estudiantes del aula (como en la p√°gina de asistencias)
          // NO filtrar por created_at porque los estudiantes pueden haber sido agregados despu√©s
          // pero a√∫n as√≠ deber√≠an tener asistencia registrada para fechas anteriores
          const registradosEnFecha = estudiantesAula.length
          
          // Verificar qu√© estudiantes NO tienen asistencia registrada en esta fecha
          const estudiantesSinAsistencia: string[] = []
          estudiantesAula.forEach(estudiante => {
            if (!estudiantesConAsistencia.has(estudiante.id)) {
              estudiantesSinAsistencia.push(estudiante.id)
            }
          })
          
          // Un d√≠a est√° completo solo si TODOS los estudiantes tienen estado (presente/falt√≥/permiso).
          // Si falta el registro de alg√∫n estudiante, ese d√≠a NO cuenta para el porcentaje.
          if (marcados === registradosEnFecha && registradosEnFecha > 0) {
            // D√≠a completo: todos los estudiantes est√°n marcados, contar como d√≠a de clases
            diasDeClases++
            
            // Contar asistencias "presente" solo de este d√≠a completo
            estudiantesAula.forEach(estudiante => {
              const key = `${estudiante.id}-${fechaStr}`
              const estado = todasAsistenciasPorEstudianteFecha[key]
              if (estado === 'presente') {
                totalAsistenciasPresente++
              }
            })
          } else if (marcados > 0 && marcados < registradosEnFecha) {
            // D√≠a incompleto: hay algunos estudiantes marcados pero no todos los que deber√≠an tener asistencia
            console.log('‚ö†Ô∏è [ReporteMensual] D√≠a incompleto detectado:', {
              fecha: fechaStr,
              aula: aula.nombre,
              marcados,
              registrados,
              registradosEnFecha,
              estudiantesSinAsistencia: estudiantesSinAsistencia.length,
              estudiantesSinAsistenciaIds: estudiantesSinAsistencia.slice(0, 10), // Primeros 10 para depuraci√≥n
              estudiantesConAsistenciaIds: Array.from(estudiantesConAsistencia).slice(0, 10),
              estudiantesAulaTotal: estudiantesAula.length
            })
            
            diasIncompletosGlobales.push({
              fecha: fechaStr,
              fechaFormateada: fechaDate.toLocaleDateString('es-PE', { day: 'numeric', month: 'long', timeZone: 'America/Lima' }),
              nivel: aula.nombre,
              aulaId: aula.id,
              marcados,
              total: registradosEnFecha, // Usar el total de estudiantes del aula
            })
          }
          // Si marcados === 0 y registradosEnFecha === 0, es un d√≠a sin estudiantes (no se marca como incompleto ni completo)
          // Si marcados === 0 pero registradosEnFecha > 0, es un d√≠a sin clases (no se marca como incompleto, pero tampoco como completo)
          // Si marcados === 0, es un d√≠a sin clases (no se marca como incompleto ni completo)
        }

        // Asisten. Promed = total de asisti√≥ / d√≠as de atenci√≥n
        // Ejemplo: 24 = 48 / 2
        const asistenPromed = diasDeClases > 0
          ? totalAsistenciasPresente / diasDeClases
          : 0

        // Calcular porcentaje: (total de asistencias) / (d√≠as de clases √ó n√∫mero de estudiantes) √ó 100
        const oportunidadesAsistencia = diasDeClases * registrados
        const porcentaje = oportunidadesAsistencia > 0 ? (totalAsistenciasPresente / oportunidadesAsistencia) * 100 : 0

        niveles.push({
          nivel: aula.nombre,
          tutor: aulaTutorMap.get(aula.id) || 'Sin tutor',
          asistenPromed,
          registrados,
          porcentaje,
          diasDeClases, // Guardar temporalmente para calcular el total
          totalAsistenciasPresente, // Guardar temporalmente para calcular el total
        })

        // Para el total, sumar las asistencias totales, no los promedios
        totalAsistenPromed += totalAsistenciasPresente
        totalRegistrados += registrados
        totalOportunidadesAsistencia += oportunidadesAsistencia
      })

      // Calcular promedio total: total de asisti√≥ / d√≠as de atenci√≥n
      // Ejemplo: 2 = 20 / 10
      const totalDiasAtencion = niveles.reduce((sum, nivel) => sum + (nivel as any).diasDeClases, 0)
      const promedioTotal = totalDiasAtencion > 0
        ? totalAsistenPromed / totalDiasAtencion
        : 0

      // Limpiar los datos temporales antes de guardar
      const nivelesActualizados = niveles.map(({ diasDeClases, totalAsistenciasPresente, ...rest }) => rest)

      // Calcular porcentaje total: (total de asistencias) / (total de oportunidades de asistencia) √ó 100
      const totalPorcentaje = totalOportunidadesAsistencia > 0 ? (totalAsistenPromed / totalOportunidadesAsistencia) * 100 : 0

      setReporteData({
        fcp: {
          id: fcpData.id,
          razon_social: (fcpData as any).razon_social || (fcpData as any).numero_identificacion || 'FCP',
          numero_identificacion: (fcpData as any).numero_identificacion,
        },
        year: selectedYear,
        month: selectedMonth,
        niveles: nivelesActualizados,
        totalAsistenPromed: promedioTotal, // Usar el promedio total, no la suma
        totalRegistrados,
        totalPorcentaje,
        diasIncompletos: diasIncompletosGlobales.sort((a, b) => a.fecha.localeCompare(b.fecha)),
      })
    } catch (error) {
      console.error('Error generating report:', error)
      toast.error('Error al generar el reporte', 'Intenta nuevamente.')
    } finally {
      setLoading(false)
    }
  }

  const exportarPDF = async () => {
    if (!reporteData) return

    try {
      const jsPDF = (await import('jspdf')).default
      const autotableModule = await import('jspdf-autotable')

      let autoTable: any = null
      if ((autotableModule as any).autoTable && typeof (autotableModule as any).autoTable === 'function') {
        autoTable = (autotableModule as any).autoTable
      } else if ((autotableModule as any).default && typeof (autotableModule as any).default === 'function') {
        autoTable = (autotableModule as any).default
      }

      if ((autotableModule as any).applyPlugin && typeof (autotableModule as any).applyPlugin === 'function') {
        (autotableModule as any).applyPlugin(jsPDF)
      }

      const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' })
      const pageWidth = doc.internal.pageSize.getWidth()

      const monthNames = [
        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
        'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
      ]

      let y = 12

      // T√≠tulo
      doc.setFontSize(12)
      doc.setFont('helvetica', 'bold')
      doc.text('RESUMEN MENSUAL DE PROYECTO', pageWidth / 2, y, { align: 'center' })
      y += 4

      // Informaci√≥n del proyecto (tres columnas)
      doc.setFontSize(8)
      doc.setFont('helvetica', 'normal')
      const col1 = 20
      const col2 = pageWidth / 3 + 10
      const col3 = (pageWidth / 3) * 2 + 10
      
      doc.text(`PROYECTO: ${reporteData.fcp.numero_identificacion || ''} ${reporteData.fcp.razon_social}`, col1, y)
      doc.text(`A√ëO: ${reporteData.year}`, col2, y)
      doc.text(`MES: ${monthNames[reporteData.month].toUpperCase()}`, col3, y)
      y += 4
      if (responsable) {
        doc.text(`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, col1, y)
        doc.text(`EMAIL: ${responsable.email.toUpperCase()}`, col2, y)
        doc.text(`ROL: ${responsable.rol.toUpperCase()}`, col3, y)
        y += 4
      }
      y += 4

      // Secci√≥n I
      doc.setFontSize(9)
      doc.setFont('helvetica', 'bold')
      doc.text('I. ASISTENCIA CONTACTO ESENCIAL', 20, y)
      y += 5

      // Preparar datos para la tabla
      const headers: string[] = ['Nivel', 'Tutor', 'Asisten. Promed', 'Registrados', 'Porcentaje']
      const body: any[] = []

      reporteData.niveles.forEach((nivel) => {
        body.push([
          nivel.nivel,
          nivel.tutor || 'Sin tutor',
          nivel.asistenPromed.toFixed(2),
          nivel.registrados.toString(),
          `${nivel.porcentaje.toFixed(2)}%`,
        ])
      })

      // Fila de totales
      body.push([
        'Total',
        '‚Äî',
        reporteData.totalAsistenPromed.toFixed(2),
        reporteData.totalRegistrados.toString(),
        `${reporteData.totalPorcentaje.toFixed(2)}%`,
      ])

      const availableWidth = getAvailableTableWidth(doc, 20)
      const columnConfigs: PDFTableColumnConfig[] = [
        { type: 'text', weight: 1.5, halign: 'left' },
        { type: 'text', weight: 1.2, halign: 'left' },
        { type: 'numeric', weight: 1, halign: 'center' },
        { type: 'numeric', weight: 1, halign: 'center' },
        { type: 'numeric', weight: 1, halign: 'center' },
      ]
      const columnStyles = getProportionalColumnStyles(5, availableWidth, columnConfigs)

      const tableOptions = {
        startY: y,
        head: [headers],
        body: body,
        theme: 'grid',
        tableWidth: availableWidth,
        margin: { left: 20, right: 20 },
        headStyles: getPDFHeaderStyles(),
        bodyStyles: getPDFBodyStyles(),
        alternateRowStyles: getPDFAlternateRowStyles(),
        styles: {
          cellPadding: 3,
          overflow: 'linebreak',
        },
        columnStyles,
        didParseCell: function (data: any) {
          // Resaltar fila de totales
          try {
            const cellText = (data.cell?.text?.toString() || data.cell?.text || '').toString().trim()
            if (cellText === 'Total') {
              data.cell.styles.fillColor = getPDFTotalRowColor()
              data.cell.styles.fontStyle = 'bold'
              data.cell.styles.textColor = getPDFCellTextColor()
              return
            }

            if (data.table && data.table.body) {
              const rowIndex = data.rowIndex
              if (rowIndex !== undefined && rowIndex >= 0) {
                const row = data.table.body[rowIndex]
                if (row) {
                  const cells = Array.isArray(row) ? row : (row.cells || Object.values(row))
                  if (Array.isArray(cells)) {
                    const hasTotal = cells.some((cell: any) => {
                      const text = (cell?.text?.toString() || cell?.text || cell?.toString() || '').toString().trim()
                      return text === 'Total'
                    })

                    if (hasTotal) {
                      data.cell.styles.fillColor = getPDFTotalRowColor()
                      data.cell.styles.fontStyle = 'bold'
                      data.cell.styles.textColor = getPDFCellTextColor()
                    }
                  }
                }
              }
            }
          } catch (e) {
            console.warn('Error en didParseCell:', e)
          }
        },
      }

      if (typeof (doc as any).autoTable === 'function') {
        (doc as any).autoTable(tableOptions)
      } else if (typeof autoTable === 'function') {
        autoTable(doc, tableOptions)
      } else {
        throw new Error('autoTable no est√° disponible. Verifica la instalaci√≥n de jspdf-autotable.')
      }

      // Descargar
      const nombreArchivo = `Resumen_Mensual_${reporteData.fcp.razon_social}_${monthNames[reporteData.month]}_${reporteData.year}.pdf`
      doc.save(nombreArchivo)
    } catch (error) {
      console.error('Error exporting to PDF:', error)
      toast.error('Error al exportar a PDF', 'Intenta nuevamente.')
    }
  }

  const exportarExcel = async () => {
    if (!reporteData) return

    try {
      const XLSX = await import('xlsx-js-style')
      const wb = XLSX.utils.book_new()

      const monthNames = [
        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
        'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
      ]

      // Estilos con colores del tema
      const headerStyle = getExcelHeaderStyle()
      const cellStyle = getExcelCellStyle()
      const alternateRowStyle = getExcelAlternateRowStyle()
      const totalStyle = getExcelTotalStyle()

      // Helper para aplicar estilos a un rango
      const applyStyle = (ws: any, range: string, style: any) => {
        const cellRange = XLSX.utils.decode_range(range)
        for (let R = cellRange.s.r; R <= cellRange.e.r; ++R) {
          for (let C = cellRange.s.c; C <= cellRange.e.c; ++C) {
            const cellAddress = XLSX.utils.encode_cell({ c: C, r: R })
            if (!ws[cellAddress]) ws[cellAddress] = { t: 's', v: '' }
            ws[cellAddress].s = style
          }
        }
      }

      // Datos del reporte (tres columnas)
      const datos = [
        ['RESUMEN MENSUAL DE PROYECTO'],
        [],
        [`PROYECTO: ${reporteData.fcp.numero_identificacion || ''} ${reporteData.fcp.razon_social}`, `A√ëO: ${reporteData.year}`, `MES: ${monthNames[reporteData.month].toUpperCase()}`],
        ...(responsable ? [[`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, `EMAIL: ${responsable.email.toUpperCase()}`, `ROL: ${responsable.rol.toUpperCase()}`]] : []),
        [],
        ['I. ASISTENCIA CONTACTO ESENCIAL'],
        [],
        ['Nivel', 'Tutor', 'Asisten. Promed', 'Registrados', 'Porcentaje'],
        ...reporteData.niveles.map(nivel => [
          nivel.nivel,
          nivel.tutor || 'Sin tutor',
          nivel.asistenPromed.toFixed(2),
          nivel.registrados,
          `${nivel.porcentaje.toFixed(2)}%`,
        ]),
        [
          'Total',
          '‚Äî',
          reporteData.totalAsistenPromed.toFixed(2),
          reporteData.totalRegistrados,
          `${reporteData.totalPorcentaje.toFixed(2)}%`,
        ],
      ]

      // Calcular el √≠ndice del encabezado despu√©s de construir el array
      // Contamos las filas hasta llegar al encabezado 'Niveles'
      // 1: T√≠tulo, 2: vac√≠a, 3-6: info (5 filas), +2 si hay responsable, +2: vac√≠a y secci√≥n, +1: vac√≠a = 10 o 12
      const headerRowIndex = 10 + (responsable ? 2 : 0) // √çndice de la fila de encabezado (0-based)

      const ws = XLSX.utils.aoa_to_sheet(datos)
      
      // Aplicar estilos
      // T√≠tulo
      ws['A1'].s = { font: { bold: true, sz: 16 }, alignment: { horizontal: 'center' } }
      // Subt√≠tulo (I. ASISTENCIA CONTACTO ESENCIAL)
      const subtituloRowIndex = 8 + (responsable ? 2 : 0)
      const subtituloCell = XLSX.utils.encode_cell({ c: 0, r: subtituloRowIndex })
      if (ws[subtituloCell]) {
        ws[subtituloCell].s = { font: { bold: true, sz: 12 } }
      }
      
      // Encabezado de tabla
      const headerRange = XLSX.utils.encode_range({ s: { c: 0, r: headerRowIndex }, e: { c: 4, r: headerRowIndex } })
      applyStyle(ws, headerRange, headerStyle)
      
      // Celdas de datos con filas alternadas
      const dataStartRow = headerRowIndex + 1
      const dataEndRow = headerRowIndex + reporteData.niveles.length
      if (reporteData.niveles.length > 0) {
        for (let R = dataStartRow; R <= dataEndRow; ++R) {
          const rowRange = XLSX.utils.encode_range({ s: { c: 0, r: R }, e: { c: 4, r: R } })
          const isEvenRow = (R - dataStartRow) % 2 === 0
          applyStyle(ws, rowRange, isEvenRow ? cellStyle : alternateRowStyle)
        }
      }
      
      // Fila de totales
      const totalRow = headerRowIndex + 1 + reporteData.niveles.length
      const totalRange = XLSX.utils.encode_range({ s: { c: 0, r: totalRow }, e: { c: 4, r: totalRow } })
      applyStyle(ws, totalRange, totalStyle)
      
      // Anchos de columna
      ws['!cols'] = [{ wch: 20 }, { wch: 25 }, { wch: 18 }, { wch: 15 }, { wch: 15 }]
      
      XLSX.utils.book_append_sheet(wb, ws, 'Resumen Mensual')

      const nombreArchivo = `Resumen_Mensual_${reporteData.fcp.razon_social}_${monthNames[reporteData.month]}_${reporteData.year}.xlsx`
      XLSX.writeFile(wb, nombreArchivo)
    } catch (error) {
      console.error('Error exporting to Excel:', error)
      toast.error('Error al exportar a Excel', 'Intenta nuevamente.')
    }
  }

  if (!selectedFCP && userFCPs.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <Calendar className="h-12 w-12 text-muted-foreground mb-4 animate-pulse" />
          <p className="text-muted-foreground">Cargando reporte mensual...</p>
        </CardContent>
      </Card>
    )
  }

  if (!roleLoading && !canViewReports) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <Calendar className="h-12 w-12 text-muted-foreground mb-4" />
          <p className="text-muted-foreground mb-4">
            No tienes permisos para ver reportes. Solo los facilitadores, directores y secretarios pueden acceder a esta funcionalidad.
          </p>
        </CardContent>
      </Card>
    )
  }

  const monthNames = [
    'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
    'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
  ]

  return (
    <div>
      <Card className="mb-6">
        <CardHeader>
          <CardTitle>Configurar Reporte Mensual</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Selector de FCP para facilitadores y otros roles (si no viene desde prop) */}
            {!fcpIdProp && userFCPs.length > 0 && (
              <div>
                <label className="text-sm font-medium mb-2 block">Proyecto (FCP):</label>
                <Select
                  value={selectedFCP || ''}
                  onValueChange={(value) => {
                    setSelectedFCP(value)
                    if (isFacilitador) {
                      setReporteData(null) // Limpiar reporte anterior al cambiar FCP
                    }
                  }}
                >
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="Seleccionar proyecto">
                      {selectedFCP ? (
                        <div className="flex items-center gap-2">
                          <Building2 className="h-4 w-4" />
                          <span className="truncate">{userFCPs.find(fcp => fcp.id === selectedFCP)?.nombre || 'Seleccionar proyecto'}</span>
                        </div>
                      ) : (
                        'Seleccionar proyecto'
                      )}
                    </SelectValue>
                  </SelectTrigger>
                  <SelectContent>
                  {userFCPs.map((fcp) => (
                      <SelectItem key={fcp.id} value={fcp.id}>
                        <div className="flex items-center gap-2">
                          <Building2 className="h-4 w-4 flex-shrink-0" />
                          <span className="truncate">{fcp.nombre}</span>
                          {fcp.numero_identificacion && (
                            <span className="text-xs text-muted-foreground whitespace-nowrap">({fcp.numero_identificacion})</span>
                          )}
                        </div>
                      </SelectItem>
                  ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            <div>
              <label className="text-sm font-medium mb-2 block">Mes:</label>
              <MonthPicker
                value={`${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}`}
                onChange={(value) => {
                  const [year, month] = value.split('-')
                  setSelectedYear(parseInt(year))
                  setSelectedMonth(parseInt(month) - 1)
                }}
                className="w-full"
              />
            </div>
          </div>

          <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador', 'director', 'secretario']}>
            <div className="mt-4">
              <Button onClick={generarReporte} disabled={loading || !selectedFCP}>
                {loading ? (
                  <>
                    <Calendar className="mr-2 h-4 w-4 animate-pulse" />
                    Generando...
                  </>
                ) : (
                  <>
                    <Calendar className="mr-2 h-4 w-4" />
                    Generar Reporte
                  </>
                )}
              </Button>
              {isFacilitador && !selectedFCP && (
                <p className="text-sm text-muted-foreground mt-2">
                  Por favor, selecciona un proyecto para generar el reporte.
                </p>
              )}
            </div>
          </RoleGuard>
        </CardContent>
      </Card>

      {reporteData && (
        <Card>
          <CardHeader>
            <div className="flex flex-col gap-4 sm:flex-row sm:items-start sm:justify-between">
              <CardTitle className="min-w-0 flex-1">Reporte Mensual Generado</CardTitle>
              <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador', 'director', 'secretario']}>
                <div className="flex flex-shrink-0 flex-wrap gap-2">
                  <Button variant="outline" onClick={exportarExcel}>
                    <FileSpreadsheet className="mr-2 h-4 w-4" />
                    Excel
                  </Button>
                  <Button variant="outline" onClick={exportarPDF}>
                    <FileText className="mr-2 h-4 w-4" />
                    PDF
                  </Button>
                </div>
              </RoleGuard>
            </div>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <div className="text-sm text-muted-foreground mb-4 grid grid-cols-1 gap-y-1 gap-x-8 sm:grid-cols-2 lg:grid-cols-3">
                <p><strong>PROYECTO:</strong> {reporteData.fcp.numero_identificacion || ''} {reporteData.fcp.razon_social}</p>
                <p><strong>A√ëO:</strong> {reporteData.year}</p>
                <p><strong>MES:</strong> {monthNames[reporteData.month].toUpperCase()}</p>
                {responsable && (
                  <>
                    <p><strong>RESPONSABLE:</strong> {responsable.nombre.toUpperCase()}</p>
                    <p><strong>EMAIL:</strong> {responsable.email.toUpperCase()}</p>
                    <p><strong>ROL:</strong> {responsable.rol.toUpperCase()}</p>
                  </>
                )}
              </div>

              {reporteData.diasIncompletos.length > 0 && (
                <div className="mb-4 rounded-md bg-warning/20 border border-warning/50 p-4">
                  <h4 className="font-semibold text-warning-foreground mb-2">
                    ‚ö†Ô∏è D√≠as con asistencia incompleta
                  </h4>
                  <p className="text-sm text-warning-foreground mb-2">
                    Los siguientes d√≠as no se complet√≥ la asistencia de todos los estudiantes. Estos d√≠as <strong>no se incluyen</strong> en los totales del reporte:
                  </p>
                  <ul className="text-sm text-warning-foreground space-y-2">
                      {reporteData.diasIncompletos.map((dia, index) => {
                        // Parsear fecha como fecha local para evitar problemas de zona horaria
                        const [year, month, day] = dia.fecha.split('-').map(Number)
                        const fechaDate = new Date(year, month - 1, day)
                        const yearForUrl = fechaDate.getFullYear()
                        const monthForUrl = fechaDate.getMonth()
                        const asistenciasUrl = `/asistencias?fcpId=${selectedRole?.fcpId || selectedFCP || ''}&aulaId=${dia.aulaId}&month=${monthForUrl}&year=${yearForUrl}&date=${dia.fecha}`
                      
                      return (
                        <li key={`${dia.fecha}-${dia.nivel}-${index}`} className="flex items-center justify-between gap-3 p-2 rounded-md bg-warning/30 border border-warning/60">
                          <span className="flex-1">
                            ‚Ä¢ <strong>{dia.fechaFormateada}</strong> - Nivel: <strong>{dia.nivel}</strong> - Marcados: {dia.marcados}/{dia.total} estudiantes
                          </span>
                          <Button
                            type="button"
                            size="sm"
                            variant="outline"
                            onClick={() => router.push(asistenciasUrl)}
                            className="ml-auto text-blue-600 dark:text-blue-400 border-blue-300 dark:border-blue-700 hover:bg-blue-50 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-300 whitespace-nowrap"
                          >
                            <Calendar className="h-4 w-4 mr-1.5" />
                            {role === 'facilitador' ? 'Ver asistencia' : 'Corregir asistencia'}
                          </Button>
                        </li>
                      )
                    })}
                  </ul>
                </div>
              )}

              <div>
                <h3 className="text-lg font-semibold mb-4">I. ASISTENCIA CONTACTO ESENCIAL</h3>
                {isMobile ? (
                  (() => {
                    const filtered = mobileSearch.trim()
                      ? reporteData.niveles.filter((n) =>
                          n.nivel.toLowerCase().includes(mobileSearch.toLowerCase()) ||
                          (n.tutor && n.tutor.toLowerCase().includes(mobileSearch.toLowerCase()))
                        )
                      : reporteData.niveles
                    const perPage = 8
                    const totalPages = Math.max(1, Math.ceil(filtered.length / perPage))
                    const display = filtered.slice((mobilePage - 1) * perPage, mobilePage * perPage)
                    return (
                      <div className="space-y-4">
                        <div className="relative">
                          <Input placeholder="Buscar por nivel..." value={mobileSearch} onChange={(e) => { setMobileSearch(e.target.value); setMobilePage(1) }} className="pl-9" />
                          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                        </div>
                        <div className="space-y-3">
                          {display.map((nivel) => (
                            <Card key={nivel.nivel}>
                              <CardContent className="p-4">
                                <p className="font-medium">{nivel.nivel}</p>
                                <p className="text-sm text-muted-foreground mt-1">Tutor: {nivel.tutor || 'Sin tutor asignado'}</p>
                                <div className="flex gap-4 mt-2 text-sm text-muted-foreground">
                                  <span>Asisten. Promed: {nivel.asistenPromed.toFixed(2)}</span>
                                  <span>Registrados: {nivel.registrados}</span>
                                  <span>Porcentaje: {nivel.porcentaje.toFixed(2)}%</span>
                                </div>
                              </CardContent>
                            </Card>
                          ))}
                        </div>
                        <Card>
                          <CardContent className="p-4 bg-accent/50 font-bold">
                            <p>Total</p>
                            <div className="flex gap-4 mt-2 text-sm">
                              <span>{reporteData.totalAsistenPromed.toFixed(2)}</span>
                              <span>{reporteData.totalRegistrados}</span>
                              <span>{reporteData.totalPorcentaje.toFixed(2)}%</span>
                            </div>
                          </CardContent>
                        </Card>
                        {filtered.length > perPage && (
                          <div className="flex items-center justify-between pt-4 border-t">
                            <p className="text-sm text-muted-foreground">
                              {(mobilePage - 1) * perPage + 1} - {Math.min(mobilePage * perPage, filtered.length)} de {filtered.length}
                            </p>
                            <div className="flex gap-2">
                              <Button variant="outline" size="sm" disabled={mobilePage <= 1} onClick={() => setMobilePage((p) => Math.max(1, p - 1))}>Anterior</Button>
                              <Button variant="outline" size="sm" disabled={mobilePage >= totalPages} onClick={() => setMobilePage((p) => Math.min(totalPages, p + 1))}>Siguiente</Button>
                            </div>
                          </div>
                        )}
                      </div>
                    )
                  })()
                ) : (
                <>
                <p className="mb-2 text-xs text-muted-foreground md:hidden">Desliza para ver m√°s columnas ‚Üí</p>
                <div className="table-responsive border border-border rounded-lg overflow-hidden">
                  <table className="w-full min-w-[320px] border-collapse border border-border text-sm">
                    <thead>
                      <tr className="bg-muted/50">
                        <th className="border border-border p-2 bg-muted/50 text-left text-foreground">Nivel</th>
                        <th className="border border-border p-2 bg-muted/50 text-left text-foreground">Tutor</th>
                        <th className="border border-border p-2 bg-muted/50 text-right text-foreground">Asisten. Promed</th>
                        <th className="border border-border p-2 bg-muted/50 text-right text-foreground">Registrados</th>
                        <th className="border border-border p-2 bg-muted/50 text-right text-foreground">Porcentaje</th>
                      </tr>
                    </thead>
                    <tbody>
                      {reporteData.niveles.map((nivel, index) => (
                        <tr key={index} className={`border-b border-border ${index % 2 === 0 ? 'bg-background' : 'bg-muted/30'} hover:bg-accent/50`}>
                          <td className="border border-border p-2 text-foreground">{nivel.nivel}</td>
                          <td className="border border-border p-2 text-muted-foreground">{nivel.tutor || 'Sin tutor'}</td>
                          <td className="border border-border p-2 text-right text-foreground">{nivel.asistenPromed.toFixed(2)}</td>
                          <td className="border border-border p-2 text-right text-foreground">{nivel.registrados}</td>
                          <td className="border border-border p-2 text-right text-foreground">{nivel.porcentaje.toFixed(2)}%</td>
                        </tr>
                      ))}
                      <tr className="bg-accent font-bold">
                        <td className="border border-border p-2 text-foreground">Total</td>
                        <td className="border border-border p-2 text-muted-foreground">‚Äî</td>
                        <td className="border border-border p-2 text-right text-foreground">{reporteData.totalAsistenPromed.toFixed(2)}</td>
                        <td className="border border-border p-2 text-right text-foreground">{reporteData.totalRegistrados}</td>
                        <td className="border border-border p-2 text-right text-foreground">{reporteData.totalPorcentaje.toFixed(2)}%</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
                </>
                )}
              </div>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}

