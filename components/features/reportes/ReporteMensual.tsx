'use client'

import React, { useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { MonthPicker } from '@/components/ui/month-picker'
import { FileSpreadsheet, FileText, Calendar } from 'lucide-react'
import { useUserRole } from '@/hooks/useUserRole'
import { RoleGuard } from '@/components/auth/RoleGuard'
import { useRouter } from 'next/navigation'
import { useSelectedRole } from '@/contexts/SelectedRoleContext'
import { useSearchParams } from 'next/navigation'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Building2 } from 'lucide-react'
import {
  getExcelHeaderStyle,
  getExcelCellStyle,
  getExcelAlternateRowStyle,
  getExcelTotalStyle,
  getPDFHeaderStyles,
  getPDFBodyStyles,
  getPDFAlternateRowStyles,
  getPDFTotalRowColor,
  getPDFCellTextColor,
} from '@/lib/utils/exportStyles'

interface ReporteMensualProps {
  fcpId: string | null
}

interface NivelData {
  nivel: string
  asistenPromed: number // Suma de asistencias "presente" en el mes
  registrados: number // Total de estudiantes activos en el nivel
  porcentaje: number // (asistenPromed / registrados) * 100
}

interface DiaIncompleto {
  fecha: string
  fechaFormateada: string
  nivel: string
  aulaId: string
  marcados: number
  total: number
}

interface ReporteData {
  fcp: { id: string; razon_social: string; numero_identificacion?: string }
  year: number
  month: number
  niveles: NivelData[]
  totalAsistenPromed: number
  totalRegistrados: number
  totalPorcentaje: number
  diasIncompletos: DiaIncompleto[]
}

export function ReporteMensual({ fcpId: fcpIdProp }: ReporteMensualProps) {
  const searchParams = useSearchParams()
  const autoGenerate = searchParams.get('auto') === 'true'
  const yearParam = searchParams.get('year')
  const monthParam = searchParams.get('month')
  
  const [loading, setLoading] = useState(false)
  const [selectedYear, setSelectedYear] = useState(
    yearParam ? parseInt(yearParam) : new Date().getFullYear()
  )
  const [selectedMonth, setSelectedMonth] = useState(
    monthParam ? parseInt(monthParam) - 1 : new Date().getMonth()
  )
  const [selectedFCP, setSelectedFCP] = useState<string | null>(fcpIdProp || null)
  const [userFCPs, setUserFCPs] = useState<Array<{ id: string; nombre: string; numero_identificacion?: string; razon_social?: string }>>([])
  const [reporteData, setReporteData] = useState<ReporteData | null>(null)
  const [facilitadorNombre, setFacilitadorNombre] = useState<string>('')
  const [responsable, setResponsable] = useState<{ nombre: string; email: string; rol: string } | null>(null)
  const [isFacilitador, setIsFacilitador] = useState(false)
  const [autoGenerated, setAutoGenerated] = useState(false)
  const { canViewReports, loading: roleLoading } = useUserRole(selectedFCP)
  const router = useRouter()
  const { selectedRole } = useSelectedRole()

  useEffect(() => {
    const initialize = async () => {
      await checkIfFacilitador()
      if (fcpIdProp) {
        setSelectedFCP(fcpIdProp)
      }
      await loadUserFCPs()
    }
    initialize()
  }, [fcpIdProp])

  // Generar reporte autom√°ticamente cuando viene desde "Ver Reporte" del dashboard
  useEffect(() => {
    if (autoGenerate && !roleLoading && !autoGenerated && !loading && !reporteData && selectedFCP) {
      // Peque√±o delay para asegurar que todo est√© listo
      const timer = setTimeout(() => {
        setAutoGenerated(true)
        generarReporte()
      }, 500)
      return () => clearTimeout(timer)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoGenerate, roleLoading, autoGenerated, loading, reporteData, selectedFCP])

  const checkIfFacilitador = async () => {
    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data: usuarioFcpData, error: usuarioFcpError } = await supabase
        .from('fcp_miembros')
        .select('rol')
        .eq('usuario_id', user.id)
        .eq('rol', 'facilitador')
        .eq('activo', true)
        .limit(1)

      if (usuarioFcpError) {
        console.error('Error checking facilitador:', usuarioFcpError)
        return
      }

      setIsFacilitador(usuarioFcpData && usuarioFcpData.length > 0)
    } catch (error) {
      console.error('Error checking facilitador:', error)
    }
  }

  const loadUserFCPs = async () => {
    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      // Verificar si el usuario es facilitador en alguna FCP
      const { data: usuarioFcpData, error: usuarioFcpError } = await supabase
        .from('fcp_miembros')
        .select('rol')
        .eq('usuario_id', user.id)
        .eq('rol', 'facilitador')
        .eq('activo', true)
        .limit(1)

      if (usuarioFcpError) throw usuarioFcpError

      const isFacilitadorCheck = usuarioFcpData && usuarioFcpData.length > 0
      setIsFacilitador(isFacilitadorCheck)

      let fcps: Array<{ id: string; nombre: string; numero_identificacion?: string; razon_social?: string }> = []

      if (isFacilitadorCheck) {
        // Facilitadores pueden ver todas las FCPs del sistema
        const { data: todasLasFCPs, error: fcpsError } = await supabase
          .from('fcps')
          .select('id, razon_social, numero_identificacion')
          .eq('activa', true)
          .order('razon_social', { ascending: true })
        
        if (fcpsError) throw fcpsError
        fcps = (todasLasFCPs || []).map((fcp: any) => ({
          id: fcp.id,
          nombre: fcp.razon_social || 'FCP',
          numero_identificacion: fcp.numero_identificacion,
          razon_social: fcp.razon_social,
        }))
      } else {
        // Usuarios no facilitadores solo ven sus FCPs
        const { data, error } = await supabase
          .from('fcp_miembros')
          .select(`
            fcp_id,
            fcp:fcps(id, razon_social, numero_identificacion)
          `)
          .eq('usuario_id', user.id)
          .eq('activo', true)

        if (error) throw error

        fcps = data?.map((item: any) => ({
          id: item.fcp.id,
          nombre: item.fcp.razon_social || item.fcp.numero_identificacion || 'FCP',
          numero_identificacion: item.fcp.numero_identificacion,
          razon_social: item.fcp.razon_social,
        })) || []
      }

      setUserFCPs(fcps)
      // Solo auto-seleccionar FCP si NO es facilitador (facilitadores deben elegir manualmente)
      if (fcps.length > 0 && !selectedFCP && !isFacilitadorCheck && !fcpIdProp) {
        setSelectedFCP(fcps[0].id)
      }
    } catch (error) {
      console.error('Error loading FCPs:', error)
    }
  }

  const loadFacilitador = async (fcpId: string) => {
    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      // Obtener el primer facilitador de la FCP
      const { data, error } = await supabase
        .from('fcp_miembros')
        .select(`
          usuario:usuarios(nombre_completo, email)
        `)
        .eq('fcp_id', fcpId)
        .eq('rol', 'facilitador')
        .eq('activo', true)
        .limit(1)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading facilitador:', error)
        return
      }

      if (data) {
        const usuario = data.usuario as any
        const nombre = usuario?.nombre_completo || usuario?.email || ''
        setFacilitadorNombre(nombre)
      } else {
        setFacilitadorNombre('')
      }
    } catch (error) {
      console.error('Error loading facilitador:', error)
      setFacilitadorNombre('')
    }
  }

  const generarReporte = async () => {
    // Usar el fcpId del rol seleccionado si est√° disponible, de lo contrario usar selectedFCP
    const fcpIdParaReporte = selectedRole?.fcpId || selectedFCP
    
    if (!fcpIdParaReporte) {
      alert('Por favor, selecciona una FCP o aseg√∫rate de tener un rol seleccionado')
      return
    }

    console.log('üìä [ReporteMensual] Generando reporte con:', {
      fcpIdParaReporte,
      selectedFCP,
      selectedRoleFcpId: selectedRole?.fcpId,
      selectedRole: selectedRole?.role
    })

    try {
      setLoading(true)
      const supabase = createClient()

      // Obtener datos del usuario actual (responsable) usando el rol seleccionado
      const { data: { user } } = await supabase.auth.getUser()
      if (user && selectedRole) {
        // Usar el rol seleccionado del contexto
        const rolSeleccionado = selectedRole.role
        
        // Obtener datos del usuario desde la tabla usuarios
        const { data: usuarioData, error: usuarioError } = await supabase
          .from('usuarios')
          .select('nombre_completo, email')
          .eq('id', user.id)
          .single()

        // Si no est√° en usuarios, obtener desde auth.users metadata
        let nombreCompleto = usuarioData?.nombre_completo || user.user_metadata?.full_name || user.user_metadata?.name || ''
        let emailUsuario = usuarioData?.email || user.email || ''

        // Mapear el rol a formato legible
        const rolFormateado = rolSeleccionado === 'facilitador' ? 'Facilitador' 
          : rolSeleccionado === 'director' ? 'Director' 
          : rolSeleccionado === 'secretario' ? 'Secretario' 
          : rolSeleccionado === 'tutor' ? 'Tutor' 
          : rolSeleccionado.charAt(0).toUpperCase() + rolSeleccionado.slice(1)

        console.log('üë§ [ReporteMensual] Estableciendo responsable:', {
          rolSeleccionado,
          rolFormateado,
          nombreCompleto,
          emailUsuario,
          selectedRole
        })

        setResponsable({
          nombre: nombreCompleto || emailUsuario || 'Usuario',
          email: emailUsuario,
          rol: rolFormateado,
        })
      } else if (user && !selectedRole) {
        console.warn('‚ö†Ô∏è [ReporteMensual] No hay rol seleccionado, intentando obtener desde fcp_miembros')
        // Fallback: intentar obtener desde fcp_miembros si no hay rol seleccionado
        const { data: usuarioFcpData, error: usuarioFcpError } = await supabase
          .from('fcp_miembros')
          .select(`
            rol,
            usuario:usuarios(nombre_completo, email)
          `)
          .eq('usuario_id', user.id)
          .eq('fcp_id', fcpIdParaReporte)
          .eq('activo', true)
          .limit(1)

        if (!usuarioFcpError && usuarioFcpData && usuarioFcpData.length > 0) {
          const usuarioFcp = usuarioFcpData[0]
          const usuario = usuarioFcp.usuario as any
          const rol = usuarioFcp.rol === 'facilitador' ? 'Facilitador' 
            : usuarioFcp.rol === 'director' ? 'Director' 
            : usuarioFcp.rol === 'secretario' ? 'Secretario' 
            : usuarioFcp.rol === 'tutor' ? 'Tutor' 
            : ''
          if (rol) {
            setResponsable({
              nombre: usuario?.nombre_completo || usuario?.email || user.email || '',
              email: usuario?.email || user.email || '',
              rol,
            })
          }
        }
      }

      // Obtener datos de la FCP usando el fcpId del rol seleccionado
      const { data: fcpData, error: fcpError } = await supabase
        .from('fcps')
        .select('id, razon_social, numero_identificacion')
        .eq('id', fcpIdParaReporte)
        .single()

      if (fcpError) {
        console.error('‚ùå [ReporteMensual] Error obteniendo FCP:', fcpError)
        throw fcpError
      }

      // Calcular fechas del mes
      const fechaInicio = new Date(selectedYear, selectedMonth, 1)
      const fechaFin = new Date(selectedYear, selectedMonth + 1, 0)
      fechaFin.setHours(23, 59, 59, 999)
      const fechaInicioStr = fechaInicio.toISOString().split('T')[0]
      const fechaFinStr = fechaFin.toISOString().split('T')[0]

      // Cargar facilitador
      await loadFacilitador(fcpIdParaReporte)

      // Obtener todas las aulas de la FCP usando el fcpId del rol seleccionado
      const { data: aulasData, error: aulasError } = await supabase
        .from('aulas')
        .select('id, nombre')
        .eq('fcp_id', fcpIdParaReporte)
        .eq('activa', true)
        .order('nombre', { ascending: true })

      if (aulasError) {
        console.error('‚ùå [ReporteMensual] Error obteniendo aulas:', aulasError)
        throw aulasError
      }

      // Obtener estudiantes activos por aula (incluyendo created_at para filtrar por fecha)
      const { data: estudiantesData, error: estudiantesError } = await supabase
        .from('estudiantes')
        .select('id, aula_id, created_at')
        .eq('fcp_id', fcpIdParaReporte)
        .eq('activo', true)

      if (estudiantesError) {
        console.error('‚ùå [ReporteMensual] Error obteniendo estudiantes:', estudiantesError)
        throw estudiantesError
      }

      // Obtener TODAS las asistencias del mes (para detectar d√≠as incompletos)
      const { data: todasAsistenciasData, error: todasAsistenciasError } = await supabase
        .from('asistencias')
        .select('estudiante_id, fecha, estado')
        .eq('fcp_id', fcpIdParaReporte)
        .gte('fecha', fechaInicioStr)
        .lte('fecha', fechaFinStr)

      if (todasAsistenciasError) {
        console.error('‚ùå [ReporteMensual] Error obteniendo asistencias:', todasAsistenciasError)
        throw todasAsistenciasError
      }

      // Obtener asistencias "presente" para el c√°lculo del reporte
      const asistenciasPresente = todasAsistenciasData?.filter(a => a.estado === 'presente') || []

      // Calcular datos por nivel y detectar d√≠as incompletos
      const niveles: NivelData[] = []
      let totalAsistenPromed = 0
      let totalRegistrados = 0
      let totalOportunidadesAsistencia = 0
      const diasIncompletosGlobales: DiaIncompleto[] = []

      aulasData?.forEach((aula) => {
        const estudiantesAula = estudiantesData?.filter(e => e.aula_id === aula.id) || []
        const registrados = estudiantesAula.length

        // Detectar d√≠as incompletos para esta aula
        const estudiantesAulaIds = new Set(estudiantesAula.map(e => e.id))
        const asistenciasPorFecha = new Map<string, Set<string>>() // fecha -> Set<estudiante_id>

        todasAsistenciasData?.forEach(asistencia => {
          if (estudiantesAulaIds.has(asistencia.estudiante_id)) {
            const fecha = asistencia.fecha
            if (!asistenciasPorFecha.has(fecha)) {
              asistenciasPorFecha.set(fecha, new Set())
            }
            // Agregar el estudiante si tiene asistencia registrada (cualquier estado: presente, falt√≥, permiso)
            asistenciasPorFecha.get(fecha)!.add(asistencia.estudiante_id)
          }
        })
        
        // Log detallado para depuraci√≥n (solo para el primer d√≠a del mes para no saturar)
        if (aula.id === aulasData?.[0]?.id) {
          const primerDia = `${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}-01`
          const asistenciasPrimerDia = asistenciasPorFecha.get(primerDia) || new Set()
          console.log('üìä [ReporteMensual] Verificaci√≥n detallada para aula:', {
            aula: aula.nombre,
            totalEstudiantes: registrados,
            primerDia,
            estudiantesConAsistenciaPrimerDia: asistenciasPrimerDia.size,
            estudiantesIds: Array.from(estudiantesAulaIds).slice(0, 10),
            estudiantesConAsistenciaIds: Array.from(asistenciasPrimerDia).slice(0, 10)
          })
        }

        // Validar d√≠as completos y contar d√≠as de clases
        let diasDeClases = 0
        let totalAsistenciasPresente = 0
        const todasAsistenciasPorEstudianteFecha: { [key: string]: string } = {}
        todasAsistenciasData?.forEach(asistencia => {
          if (estudiantesAulaIds.has(asistencia.estudiante_id)) {
            const key = `${asistencia.estudiante_id}-${asistencia.fecha}`
            todasAsistenciasPorEstudianteFecha[key] = asistencia.estado
          }
        })

        // Verificar cada fecha del mes para detectar d√≠as incompletos
        // Generar todas las fechas del mes seleccionado
        const diasDelMes = new Date(selectedYear, selectedMonth + 1, 0).getDate()
        
        for (let dia = 1; dia <= diasDelMes; dia++) {
          const fechaDate = new Date(selectedYear, selectedMonth, dia)
          const fechaStr = `${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}-${String(dia).padStart(2, '0')}`
          
          // Contar cu√°ntos estudiantes tienen asistencia registrada en esta fecha
          const estudiantesConAsistencia = asistenciasPorFecha.get(fechaStr) || new Set()
          const marcados = estudiantesConAsistencia.size
          
          // Para detectar d√≠as incompletos, usar TODOS los estudiantes del aula (como en la p√°gina de asistencias)
          // NO filtrar por created_at porque los estudiantes pueden haber sido agregados despu√©s
          // pero a√∫n as√≠ deber√≠an tener asistencia registrada para fechas anteriores
          const registradosEnFecha = estudiantesAula.length
          
          // Verificar qu√© estudiantes NO tienen asistencia registrada en esta fecha
          const estudiantesSinAsistencia: string[] = []
          estudiantesAula.forEach(estudiante => {
            if (!estudiantesConAsistencia.has(estudiante.id)) {
              estudiantesSinAsistencia.push(estudiante.id)
            }
          })
          
          // Verificar si todos los estudiantes del aula tienen asistencia registrada
          // Un d√≠a est√° completo si TODOS los estudiantes tienen asistencia registrada (presente, falt√≥ o permiso)
          if (marcados === registradosEnFecha && registradosEnFecha > 0) {
            // D√≠a completo: todos los estudiantes est√°n marcados, contar como d√≠a de clases
            diasDeClases++
            
            // Contar asistencias "presente" solo de este d√≠a completo
            estudiantesAula.forEach(estudiante => {
              const key = `${estudiante.id}-${fechaStr}`
              const estado = todasAsistenciasPorEstudianteFecha[key]
              if (estado === 'presente') {
                totalAsistenciasPresente++
              }
            })
          } else if (marcados > 0 && marcados < registradosEnFecha) {
            // D√≠a incompleto: hay algunos estudiantes marcados pero no todos los que deber√≠an tener asistencia
            console.log('‚ö†Ô∏è [ReporteMensual] D√≠a incompleto detectado:', {
              fecha: fechaStr,
              aula: aula.nombre,
              marcados,
              registrados,
              registradosEnFecha,
              estudiantesSinAsistencia: estudiantesSinAsistencia.length,
              estudiantesSinAsistenciaIds: estudiantesSinAsistencia.slice(0, 10), // Primeros 10 para depuraci√≥n
              estudiantesConAsistenciaIds: Array.from(estudiantesConAsistencia).slice(0, 10),
              estudiantesAulaTotal: estudiantesAula.length
            })
            
            diasIncompletosGlobales.push({
              fecha: fechaStr,
              fechaFormateada: fechaDate.toLocaleDateString('es-ES', { day: 'numeric', month: 'long' }),
              nivel: aula.nombre,
              aulaId: aula.id,
              marcados,
              total: registradosEnFecha, // Usar el total de estudiantes del aula
            })
          }
          // Si marcados === 0 y registradosEnFecha === 0, es un d√≠a sin estudiantes (no se marca como incompleto ni completo)
          // Si marcados === 0 pero registradosEnFecha > 0, es un d√≠a sin clases (no se marca como incompleto, pero tampoco como completo)
          // Si marcados === 0, es un d√≠a sin clases (no se marca como incompleto ni completo)
        }

        // Asisten. Promed = total de asisti√≥ / d√≠as de atenci√≥n
        // Ejemplo: 24 = 48 / 2
        const asistenPromed = diasDeClases > 0
          ? totalAsistenciasPresente / diasDeClases
          : 0

        // Calcular porcentaje: (total de asistencias) / (d√≠as de clases √ó n√∫mero de estudiantes) √ó 100
        const oportunidadesAsistencia = diasDeClases * registrados
        const porcentaje = oportunidadesAsistencia > 0 ? (totalAsistenciasPresente / oportunidadesAsistencia) * 100 : 0

        niveles.push({
          nivel: aula.nombre,
          asistenPromed,
          registrados,
          porcentaje,
          diasDeClases, // Guardar temporalmente para calcular el total
          totalAsistenciasPresente, // Guardar temporalmente para calcular el total
        })

        // Para el total, sumar las asistencias totales, no los promedios
        totalAsistenPromed += totalAsistenciasPresente
        totalRegistrados += registrados
        totalOportunidadesAsistencia += oportunidadesAsistencia
      })

      // Calcular promedio total: total de asisti√≥ / d√≠as de atenci√≥n
      // Ejemplo: 2 = 20 / 10
      const totalDiasAtencion = niveles.reduce((sum, nivel) => sum + (nivel as any).diasDeClases, 0)
      const promedioTotal = totalDiasAtencion > 0
        ? totalAsistenPromed / totalDiasAtencion
        : 0

      // Limpiar los datos temporales antes de guardar
      const nivelesActualizados = niveles.map(({ diasDeClases, totalAsistenciasPresente, ...rest }) => rest)

      // Calcular porcentaje total: (total de asistencias) / (total de oportunidades de asistencia) √ó 100
      const totalPorcentaje = totalOportunidadesAsistencia > 0 ? (totalAsistenPromed / totalOportunidadesAsistencia) * 100 : 0

      setReporteData({
        fcp: {
          id: fcpData.id,
          razon_social: (fcpData as any).razon_social || (fcpData as any).numero_identificacion || 'FCP',
          numero_identificacion: (fcpData as any).numero_identificacion,
        },
        year: selectedYear,
        month: selectedMonth,
        niveles: nivelesActualizados,
        totalAsistenPromed: promedioTotal, // Usar el promedio total, no la suma
        totalRegistrados,
        totalPorcentaje,
        diasIncompletos: diasIncompletosGlobales.sort((a, b) => a.fecha.localeCompare(b.fecha)),
      })
    } catch (error) {
      console.error('Error generating report:', error)
      alert('Error al generar el reporte. Por favor, intenta nuevamente.')
    } finally {
      setLoading(false)
    }
  }

  const exportarPDF = async () => {
    if (!reporteData) return

    try {
      const jsPDF = (await import('jspdf')).default
      const autotableModule = await import('jspdf-autotable')

      let autoTable: any = null
      if ((autotableModule as any).autoTable && typeof (autotableModule as any).autoTable === 'function') {
        autoTable = (autotableModule as any).autoTable
      } else if ((autotableModule as any).default && typeof (autotableModule as any).default === 'function') {
        autoTable = (autotableModule as any).default
      }

      if ((autotableModule as any).applyPlugin && typeof (autotableModule as any).applyPlugin === 'function') {
        (autotableModule as any).applyPlugin(jsPDF)
      }

      const doc = new jsPDF()
      const pageWidth = doc.internal.pageSize.getWidth()

      const monthNames = [
        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
        'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
      ]

      let y = 20

      // T√≠tulo
      doc.setFontSize(14)
      doc.setFont('helvetica', 'bold')
      doc.text('RESUMEN MENSUAL DE PROYECTO', pageWidth / 2, y, { align: 'center' })
      y += 10

      // Informaci√≥n del proyecto (tres columnas)
      doc.setFontSize(10)
      doc.setFont('helvetica', 'normal')
      const col1 = 20
      const col2 = pageWidth / 3 + 10
      const col3 = (pageWidth / 3) * 2 + 10
      
      doc.text(`PROYECTO: ${reporteData.fcp.numero_identificacion || ''} ${reporteData.fcp.razon_social}`, col1, y)
      doc.text(`A√ëO: ${reporteData.year}`, col2, y)
      doc.text(`MES: ${monthNames[reporteData.month].toUpperCase()}`, col3, y)
      y += 6
      if (responsable) {
        doc.text(`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, col1, y)
        doc.text(`EMAIL: ${responsable.email.toUpperCase()}`, col2, y)
        doc.text(`ROL: ${responsable.rol.toUpperCase()}`, col3, y)
        y += 6
      }
      y += 10

      // Secci√≥n I
      doc.setFontSize(11)
      doc.setFont('helvetica', 'bold')
      doc.text('I. ASISTENCIA CONTACTO ESENCIAL', 20, y)
      y += 8

      // Preparar datos para la tabla
      const headers: string[] = ['Niveles', 'Asisten. Promed', 'Registrados', 'Porcentaje']
      const body: any[] = []

      reporteData.niveles.forEach((nivel) => {
        body.push([
          nivel.nivel,
          nivel.asistenPromed.toFixed(2),
          nivel.registrados.toString(),
          `${nivel.porcentaje.toFixed(2)}%`,
        ])
      })

      // Fila de totales
      body.push([
        'Total',
        reporteData.totalAsistenPromed.toFixed(2),
        reporteData.totalRegistrados.toString(),
        `${reporteData.totalPorcentaje.toFixed(2)}%`,
      ])

      // Generar tabla con autoTable usando colores del tema
      const tableOptions = {
        startY: y,
        head: [headers],
        body: body,
        theme: 'grid',
        headStyles: getPDFHeaderStyles(),
        bodyStyles: getPDFBodyStyles(),
        alternateRowStyles: getPDFAlternateRowStyles(),
        styles: {
          cellPadding: 3,
          overflow: 'linebreak',
        },
        columnStyles: {
          0: { cellWidth: 60 }, // Niveles
          1: { cellWidth: 40, halign: 'right' }, // Asisten. Promed
          2: { cellWidth: 40, halign: 'right' }, // Registrados
          3: { cellWidth: 40, halign: 'right' }, // Porcentaje
        },
        didParseCell: function (data: any) {
          // Resaltar fila de totales
          try {
            const cellText = (data.cell?.text?.toString() || data.cell?.text || '').toString().trim()
            if (cellText === 'Total') {
              data.cell.styles.fillColor = getPDFTotalRowColor()
              data.cell.styles.fontStyle = 'bold'
              data.cell.styles.textColor = getPDFCellTextColor()
              return
            }

            if (data.table && data.table.body) {
              const rowIndex = data.rowIndex
              if (rowIndex !== undefined && rowIndex >= 0) {
                const row = data.table.body[rowIndex]
                if (row) {
                  const cells = Array.isArray(row) ? row : (row.cells || Object.values(row))
                  if (Array.isArray(cells)) {
                    const hasTotal = cells.some((cell: any) => {
                      const text = (cell?.text?.toString() || cell?.text || cell?.toString() || '').toString().trim()
                      return text === 'Total'
                    })

                    if (hasTotal) {
                      data.cell.styles.fillColor = getPDFTotalRowColor()
                      data.cell.styles.fontStyle = 'bold'
                      data.cell.styles.textColor = getPDFCellTextColor()
                    }
                  }
                }
              }
            }
          } catch (e) {
            console.warn('Error en didParseCell:', e)
          }
        },
        margin: { top: y, left: 20, right: 20 },
      }

      if (typeof (doc as any).autoTable === 'function') {
        (doc as any).autoTable(tableOptions)
      } else if (typeof autoTable === 'function') {
        autoTable(doc, tableOptions)
      } else {
        throw new Error('autoTable no est√° disponible. Verifica la instalaci√≥n de jspdf-autotable.')
      }

      // Descargar
      const nombreArchivo = `Resumen_Mensual_${reporteData.fcp.razon_social}_${monthNames[reporteData.month]}_${reporteData.year}.pdf`
      doc.save(nombreArchivo)
    } catch (error) {
      console.error('Error exporting to PDF:', error)
      alert('Error al exportar a PDF. Por favor, intenta nuevamente.')
    }
  }

  const exportarExcel = async () => {
    if (!reporteData) return

    try {
      const XLSX = await import('xlsx-js-style')
      const wb = XLSX.utils.book_new()

      const monthNames = [
        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
        'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
      ]

      // Estilos con colores del tema
      const headerStyle = getExcelHeaderStyle()
      const cellStyle = getExcelCellStyle()
      const alternateRowStyle = getExcelAlternateRowStyle()
      const totalStyle = getExcelTotalStyle()

      // Helper para aplicar estilos a un rango
      const applyStyle = (ws: any, range: string, style: any) => {
        const cellRange = XLSX.utils.decode_range(range)
        for (let R = cellRange.s.r; R <= cellRange.e.r; ++R) {
          for (let C = cellRange.s.c; C <= cellRange.e.c; ++C) {
            const cellAddress = XLSX.utils.encode_cell({ c: C, r: R })
            if (!ws[cellAddress]) ws[cellAddress] = { t: 's', v: '' }
            ws[cellAddress].s = style
          }
        }
      }

      // Datos del reporte (tres columnas)
      const datos = [
        ['RESUMEN MENSUAL DE PROYECTO'],
        [],
        [`PROYECTO: ${reporteData.fcp.numero_identificacion || ''} ${reporteData.fcp.razon_social}`, `A√ëO: ${reporteData.year}`, `MES: ${monthNames[reporteData.month].toUpperCase()}`],
        ...(responsable ? [[`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, `EMAIL: ${responsable.email.toUpperCase()}`, `ROL: ${responsable.rol.toUpperCase()}`]] : []),
        [],
        ['I. ASISTENCIA CONTACTO ESENCIAL'],
        [],
        ['Niveles', 'Asisten. Promed', 'Registrados', 'Porcentaje'],
        ...reporteData.niveles.map(nivel => [
          nivel.nivel,
          nivel.asistenPromed.toFixed(2),
          nivel.registrados,
          `${nivel.porcentaje.toFixed(2)}%`,
        ]),
        [
          'Total',
          reporteData.totalAsistenPromed.toFixed(2),
          reporteData.totalRegistrados,
          `${reporteData.totalPorcentaje.toFixed(2)}%`,
        ],
      ]

      // Calcular el √≠ndice del encabezado despu√©s de construir el array
      // Contamos las filas hasta llegar al encabezado 'Niveles'
      // 1: T√≠tulo, 2: vac√≠a, 3-6: info (5 filas), +2 si hay responsable, +2: vac√≠a y secci√≥n, +1: vac√≠a = 10 o 12
      const headerRowIndex = 10 + (responsable ? 2 : 0) // √çndice de la fila de encabezado (0-based)

      const ws = XLSX.utils.aoa_to_sheet(datos)
      
      // Aplicar estilos
      // T√≠tulo
      ws['A1'].s = { font: { bold: true, sz: 16 }, alignment: { horizontal: 'center' } }
      // Subt√≠tulo (I. ASISTENCIA CONTACTO ESENCIAL)
      const subtituloRowIndex = 8 + (responsable ? 2 : 0)
      const subtituloCell = XLSX.utils.encode_cell({ c: 0, r: subtituloRowIndex })
      if (ws[subtituloCell]) {
        ws[subtituloCell].s = { font: { bold: true, sz: 12 } }
      }
      
      // Encabezado de tabla
      const headerRange = XLSX.utils.encode_range({ s: { c: 0, r: headerRowIndex }, e: { c: 3, r: headerRowIndex } })
      applyStyle(ws, headerRange, headerStyle)
      
      // Celdas de datos con filas alternadas
      const dataStartRow = headerRowIndex + 1
      const dataEndRow = headerRowIndex + reporteData.niveles.length
      if (reporteData.niveles.length > 0) {
        for (let R = dataStartRow; R <= dataEndRow; ++R) {
          const rowRange = XLSX.utils.encode_range({ s: { c: 0, r: R }, e: { c: 3, r: R } })
          const isEvenRow = (R - dataStartRow) % 2 === 0
          applyStyle(ws, rowRange, isEvenRow ? cellStyle : alternateRowStyle)
        }
      }
      
      // Fila de totales
      const totalRow = headerRowIndex + 1 + reporteData.niveles.length
      const totalRange = XLSX.utils.encode_range({ s: { c: 0, r: totalRow }, e: { c: 3, r: totalRow } })
      applyStyle(ws, totalRange, totalStyle)
      
      // Anchos de columna
      ws['!cols'] = [{ wch: 25 }, { wch: 18 }, { wch: 15 }, { wch: 15 }]
      
      XLSX.utils.book_append_sheet(wb, ws, 'Resumen Mensual')

      const nombreArchivo = `Resumen_Mensual_${reporteData.fcp.razon_social}_${monthNames[reporteData.month]}_${reporteData.year}.xlsx`
      XLSX.writeFile(wb, nombreArchivo)
    } catch (error) {
      console.error('Error exporting to Excel:', error)
      alert('Error al exportar a Excel. Por favor, intenta nuevamente.')
    }
  }

  if (!selectedFCP && userFCPs.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <p className="text-muted-foreground mb-4">
            Cargando FCPs...
          </p>
        </CardContent>
      </Card>
    )
  }

  if (!roleLoading && !canViewReports) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <Calendar className="h-12 w-12 text-muted-foreground mb-4" />
          <p className="text-muted-foreground mb-4">
            No tienes permisos para ver reportes. Solo los facilitadores, directores y secretarios pueden acceder a esta funcionalidad.
          </p>
        </CardContent>
      </Card>
    )
  }

  const monthNames = [
    'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
    'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
  ]

  return (
    <div>
      <Card className="mb-6">
        <CardHeader>
          <CardTitle>Configurar Reporte Mensual</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {/* Selector de FCP para facilitadores y otros roles (si no viene desde prop) */}
            {!fcpIdProp && userFCPs.length > 0 && (
              <div>
                <label className="text-sm font-medium mb-2 block">Proyecto (FCP):</label>
                <Select
                  value={selectedFCP || ''}
                  onValueChange={(value) => {
                    setSelectedFCP(value)
                    if (isFacilitador) {
                      setReporteData(null) // Limpiar reporte anterior al cambiar FCP
                    }
                  }}
                >
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="Seleccionar proyecto">
                      {selectedFCP ? (
                        <div className="flex items-center gap-2">
                          <Building2 className="h-4 w-4" />
                          <span className="truncate">{userFCPs.find(fcp => fcp.id === selectedFCP)?.nombre || 'Seleccionar proyecto'}</span>
                        </div>
                      ) : (
                        'Seleccionar proyecto'
                      )}
                    </SelectValue>
                  </SelectTrigger>
                  <SelectContent>
                  {userFCPs.map((fcp) => (
                      <SelectItem key={fcp.id} value={fcp.id}>
                        <div className="flex items-center gap-2">
                          <Building2 className="h-4 w-4 flex-shrink-0" />
                          <span className="truncate">{fcp.nombre}</span>
                          {fcp.numero_identificacion && (
                            <span className="text-xs text-muted-foreground whitespace-nowrap">({fcp.numero_identificacion})</span>
                          )}
                        </div>
                      </SelectItem>
                  ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            <div>
              <label className="text-sm font-medium mb-2 block">Mes:</label>
              <MonthPicker
                value={`${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}`}
                onChange={(value) => {
                  const [year, month] = value.split('-')
                  setSelectedYear(parseInt(year))
                  setSelectedMonth(parseInt(month) - 1)
                }}
                className="w-full"
              />
            </div>
          </div>

          <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador', 'director', 'secretario']}>
            <div className="mt-4">
              <Button onClick={generarReporte} disabled={loading || !selectedFCP}>
                {loading ? (
                  <>
                    <Calendar className="mr-2 h-4 w-4 animate-pulse" />
                    Generando...
                  </>
                ) : (
                  <>
                    <Calendar className="mr-2 h-4 w-4" />
                    Generar Reporte
                  </>
                )}
              </Button>
              {isFacilitador && !selectedFCP && (
                <p className="text-sm text-muted-foreground mt-2">
                  Por favor, selecciona un proyecto para generar el reporte.
                </p>
              )}
            </div>
          </RoleGuard>
        </CardContent>
      </Card>

      {reporteData && (
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <CardTitle>Reporte Mensual Generado</CardTitle>
              <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador', 'director', 'secretario']}>
                <div className="flex gap-2">
                  <Button variant="outline" onClick={exportarExcel}>
                    <FileSpreadsheet className="mr-2 h-4 w-4" />
                    Excel
                  </Button>
                  <Button variant="outline" onClick={exportarPDF}>
                    <FileText className="mr-2 h-4 w-4" />
                    PDF
                  </Button>
                </div>
              </RoleGuard>
            </div>
          </CardHeader>
          <CardContent>
            <div className="space-y-6">
              <div className="text-sm text-muted-foreground mb-4 grid grid-cols-3 gap-x-8 gap-y-2">
                <p><strong>PROYECTO:</strong> {reporteData.fcp.numero_identificacion || ''} {reporteData.fcp.razon_social}</p>
                <p><strong>A√ëO:</strong> {reporteData.year}</p>
                <p><strong>MES:</strong> {monthNames[reporteData.month].toUpperCase()}</p>
                {responsable && (
                  <>
                    <p><strong>RESPONSABLE:</strong> {responsable.nombre.toUpperCase()}</p>
                    <p><strong>EMAIL:</strong> {responsable.email.toUpperCase()}</p>
                    <p><strong>ROL:</strong> {responsable.rol.toUpperCase()}</p>
                  </>
                )}
              </div>

              {reporteData.diasIncompletos.length > 0 && (
                <div className="mb-4 rounded-md bg-warning/20 border border-warning/50 p-4">
                  <h4 className="font-semibold text-warning-foreground mb-2">
                    ‚ö†Ô∏è D√≠as con asistencia incompleta
                  </h4>
                  <p className="text-sm text-warning-foreground mb-2">
                    Los siguientes d√≠as no se complet√≥ la asistencia de todos los estudiantes. Estos d√≠as <strong>no se incluyen</strong> en los totales del reporte:
                  </p>
                  <ul className="text-sm text-warning-foreground space-y-2">
                      {reporteData.diasIncompletos.map((dia, index) => {
                        // Parsear fecha como fecha local para evitar problemas de zona horaria
                        const [year, month, day] = dia.fecha.split('-').map(Number)
                        const fechaDate = new Date(year, month - 1, day)
                        const yearForUrl = fechaDate.getFullYear()
                        const monthForUrl = fechaDate.getMonth()
                        const asistenciasUrl = `/asistencias?aulaId=${dia.aulaId}&month=${monthForUrl}&year=${yearForUrl}`
                      
                      return (
                        <li key={`${dia.fecha}-${dia.nivel}-${index}`} className="flex items-center justify-between gap-3 p-2 rounded-md bg-warning/30 border border-warning/60">
                          <span className="flex-1">
                            ‚Ä¢ <strong>{dia.fechaFormateada}</strong> - Nivel: <strong>{dia.nivel}</strong> - Marcados: {dia.marcados}/{dia.total} estudiantes
                          </span>
                          <Button
                            type="button"
                            size="sm"
                            variant="outline"
                            onClick={() => router.push(asistenciasUrl)}
                            className="ml-auto text-blue-600 dark:text-blue-400 border-blue-300 dark:border-blue-700 hover:bg-blue-50 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-300 whitespace-nowrap"
                          >
                            <Calendar className="h-4 w-4 mr-1.5" />
                            Corregir asistencia
                          </Button>
                        </li>
                      )
                    })}
                  </ul>
                </div>
              )}

              <div>
                <h3 className="text-lg font-semibold mb-4">I. ASISTENCIA CONTACTO ESENCIAL</h3>
                <div className="border border-border rounded-lg overflow-hidden">
                  <table className="w-full border-collapse border border-border text-sm">
                    <thead>
                      <tr className="bg-muted/50">
                        <th className="border border-border p-2 bg-muted/50 text-left text-foreground">Niveles</th>
                        <th className="border border-border p-2 bg-muted/50 text-right text-foreground">Asisten. Promed</th>
                        <th className="border border-border p-2 bg-muted/50 text-right text-foreground">Registrados</th>
                        <th className="border border-border p-2 bg-muted/50 text-right text-foreground">Porcentaje</th>
                      </tr>
                    </thead>
                    <tbody>
                      {reporteData.niveles.map((nivel, index) => (
                        <tr key={index} className={`border-b border-border ${index % 2 === 0 ? 'bg-background' : 'bg-muted/30'} hover:bg-accent/50`}>
                          <td className="border border-border p-2 text-foreground">{nivel.nivel}</td>
                          <td className="border border-border p-2 text-right text-foreground">{nivel.asistenPromed.toFixed(2)}</td>
                          <td className="border border-border p-2 text-right text-foreground">{nivel.registrados}</td>
                          <td className="border border-border p-2 text-right text-foreground">{nivel.porcentaje.toFixed(2)}%</td>
                        </tr>
                      ))}
                      <tr className="bg-accent font-bold">
                        <td className="border border-border p-2 text-foreground">Total</td>
                        <td className="border border-border p-2 text-right text-foreground">{reporteData.totalAsistenPromed.toFixed(2)}</td>
                        <td className="border border-border p-2 text-right text-foreground">{reporteData.totalRegistrados}</td>
                        <td className="border border-border p-2 text-right text-foreground">{reporteData.totalPorcentaje.toFixed(2)}%</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}

