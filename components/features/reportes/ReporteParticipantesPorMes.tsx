'use client'

import React, { useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { FileSpreadsheet, FileText, Calendar, Building2 } from 'lucide-react'
import { useUserRole } from '@/hooks/useUserRole'
import { useSelectedRole } from '@/contexts/SelectedRoleContext'
import { RoleGuard } from '@/components/auth/RoleGuard'
import { useSearchParams, useRouter } from 'next/navigation'
import {
  getExcelHeaderStyle,
  getExcelCellStyle,
  getExcelAlternateRowStyle,
  getExcelTotalStyle,
  getPDFHeaderStyles,
  getPDFBodyStyles,
  getPDFAlternateRowStyles,
  getPDFTotalRowColor,
  getPDFCellTextColor,
} from '@/lib/utils/exportStyles'
import {
  getAvailableTableWidth,
  getFontSizeForColumns,
  getProportionalColumnStyles,
  type PDFTableColumnConfig,
} from '@/lib/utils/pdfTableUtils'
import { toast } from '@/lib/toast'

interface ReporteParticipantesPorMesProps {
  fcpId: string | null
}

interface FCPData {
  codigo: string
  nombre: string
  porcentajesPorMes: { [mes: number]: number } // mes (0-11) -> porcentaje
  numero_identificacion?: string
  razon_social?: string
}

interface DiaIncompleto {
  fecha: string
  fechaFormateada: string
  nivel: string
  aulaId: string
  marcados: number
  total: number
}

interface ReporteData {
  year: number
  fcps: FCPData[]
  totalesPorMes: { [mes: number]: number } // Porcentaje total por mes
  diasIncompletos: DiaIncompleto[] // D√≠as que no se completaron
}

export function ReporteParticipantesPorMes({ fcpId: fcpIdProp }: ReporteParticipantesPorMesProps) {
  const searchParams = useSearchParams()
  const autoGenerate = searchParams.get('auto') === 'true'
  
  const [loading, setLoading] = useState(false)
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear())
  const [selectedFCP, setSelectedFCP] = useState<string | null>(fcpIdProp || null)
  const [userFCPs, setUserFCPs] = useState<Array<{ id: string; nombre: string }>>([])
  const [reporteData, setReporteData] = useState<ReporteData | null>(null)
  const [autoGenerated, setAutoGenerated] = useState(false)
  const [responsable, setResponsable] = useState<{ nombre: string; email: string; rol: string } | null>(null)
  const { isFacilitador, loading: roleLoading } = useUserRole(selectedFCP)
  const { selectedRole } = useSelectedRole()
  const router = useRouter()

  useEffect(() => {
    const initialize = async () => {
      if (fcpIdProp) {
        setSelectedFCP(fcpIdProp)
      } else {
        await loadUserFCPs()
      }
    }
    initialize()
  }, [fcpIdProp, selectedRole?.role, selectedRole?.fcpId])

  // Generar reporte autom√°ticamente solo cuando viene desde "Ver Detalles" (auto=true)
  useEffect(() => {
    if (autoGenerate && isFacilitador && !roleLoading && !autoGenerated && !loading && !reporteData) {
      // Peque√±o delay para asegurar que todo est√© listo
      const timer = setTimeout(() => {
        setAutoGenerated(true)
        generarReporte()
      }, 500)
      return () => clearTimeout(timer)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoGenerate, isFacilitador, roleLoading, autoGenerated, loading, reporteData])

  const loadUserFCPs = async () => {
    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data: facRow } = await supabase.from('facilitadores').select('usuario_id').eq('usuario_id', user.id).maybeSingle()
      let fcps: Array<{ id: string; nombre: string; numero_identificacion?: string }> = []
      if (facRow) {
        const { data: fcpsData } = await supabase.from('fcps').select('id, razon_social, numero_identificacion').eq('facilitador_id', user.id).eq('activa', true).order('razon_social')
        fcps = (fcpsData || []).map((f: any) => ({ id: f.id, nombre: f.razon_social || f.numero_identificacion || 'FCP', numero_identificacion: f.numero_identificacion }))
      } else {
        const { data, error } = await supabase.from('fcp_miembros').select('fcp_id, fcp:fcps(id, razon_social, numero_identificacion)').eq('usuario_id', user.id).eq('activo', true).not('fcp_id', 'is', null)
        if (error) throw error
        fcps = (data || []).filter((i: any) => i.fcp).map((i: any) => ({ id: i.fcp.id, nombre: i.fcp.razon_social || i.fcp.numero_identificacion || 'FCP', numero_identificacion: i.fcp.numero_identificacion }))
      }
      if (selectedRole?.fcpId) {
        const sole = fcps.find((f: any) => f.id === selectedRole.fcpId)
        fcps = sole ? [sole] : []
      }
      setUserFCPs(fcps)
      if (fcps.length > 0 && !selectedFCP && !fcpIdProp) {
        if (selectedRole?.fcpId && fcps.some((f: any) => f.id === selectedRole.fcpId)) setSelectedFCP(selectedRole.fcpId)
        else setSelectedFCP(fcps[0].id)
      }
    } catch (error) {
      console.error('Error loading FCPs:', error)
    }
  }

  const generarReporte = async () => {
    // Para facilitadores, no necesitamos selectedFCP ya que cargamos todas las FCPs
    if (!isFacilitador && !selectedFCP) {
      toast.warning('Selecciona FCP', 'Por favor, selecciona una FCP.')
      return
    }

    try {
      setLoading(true)
      const supabase = createClient()

      // Obtener datos del usuario actual (responsable)
      const { data: { user } } = await supabase.auth.getUser()
      if (user) {
        if (isFacilitador) {
          const { data: u } = await supabase.from('usuarios').select('nombre_completo, email').eq('id', user.id).maybeSingle()
          setResponsable({
            nombre: u?.nombre_completo || (user as any).email || '',
            email: u?.email || (user as any).email || '',
            rol: 'Facilitador',
          })
        } else if (selectedFCP) {
          // Obtener rol y datos del usuario en la FCP
          const { data: usuarioFcpData, error: usuarioFcpError } = await supabase
            .from('fcp_miembros')
            .select(`
              rol,
              usuario:usuarios(nombre_completo, email)
            `)
            .eq('usuario_id', user.id)
            .eq('fcp_id', selectedFCP)
            .eq('activo', true)
            .single()

          if (!usuarioFcpError && usuarioFcpData) {
            const usuario = usuarioFcpData.usuario as any
            const rol = usuarioFcpData.rol === 'facilitador' ? 'Facilitador' : usuarioFcpData.rol === 'director' ? 'Director' : usuarioFcpData.rol === 'secretario' ? 'Secretario' : usuarioFcpData.rol === 'tutor' ? 'Tutor' : ''
            if (rol) {
              setResponsable({
                nombre: usuario?.nombre_completo || usuario?.email || user.email || '',
                email: usuario?.email || user.email || '',
                rol,
              })
            }
          }
        }
      }

      // Si el usuario es facilitador, obtener TODAS las FCPs del sistema
      // Si no es facilitador, obtener solo las FCPs del usuario
      let fcpsAConsultar: Array<{ id: string; nombre: string; numero_identificacion?: string }> = []
      
      if (isFacilitador) {
        const { data: fcpsFac, error: fcpsError } = await supabase
          .from('fcps')
          .select('id, razon_social, numero_identificacion')
          .eq('facilitador_id', user!.id)
          .eq('activa', true)
          .order('razon_social', { ascending: true })
        if (fcpsError) throw fcpsError
        fcpsAConsultar = (fcpsFac || []).map((fcp: any) => ({
          id: fcp.id,
          nombre: fcp.razon_social || fcp.numero_identificacion || 'FCP',
          numero_identificacion: fcp.numero_identificacion
        }))
      } else {
        // Usuarios no facilitadores solo ven sus FCPs
        if (fcpIdProp) {
          const { data: fcpData } = await supabase
            .from('fcps')
            .select('id, razon_social, numero_identificacion')
            .eq('id', fcpIdProp)
            .single()
          if (fcpData) {
            fcpsAConsultar = [{ id: fcpData.id, nombre: fcpData.razon_social || fcpData.numero_identificacion || 'FCP', numero_identificacion: fcpData.numero_identificacion }]
          }
        } else if (selectedFCP) {
          const { data: fcpData } = await supabase
            .from('fcps')
            .select('id, razon_social, numero_identificacion')
            .eq('id', selectedFCP)
            .single()
          if (fcpData) {
            fcpsAConsultar = [{ id: fcpData.id, nombre: fcpData.razon_social || fcpData.numero_identificacion || 'FCP', numero_identificacion: fcpData.numero_identificacion }]
          }
        } else {
          fcpsAConsultar = userFCPs.length > 0 ? userFCPs : []
        }
      }

      const fcps: FCPData[] = []
      const totalesPorMes: { [mes: number]: { asistencias: number; oportunidades: number } } = {}
      const diasIncompletosGlobales: DiaIncompleto[] = []

      // Para cada FCP, calcular porcentaje total por mes (igual que ReporteMensual)
      for (const fcp of fcpsAConsultar) {
        // Obtener todas las aulas de la FCP
        const { data: aulasData, error: aulasError } = await supabase
          .from('aulas')
          .select('id, nombre')
          .eq('fcp_id', fcp.id)
          .eq('activa', true)

        if (aulasError) throw aulasError

        // Obtener TODAS las asistencias del a√±o para esta FCP
        const fechaInicio = new Date(selectedYear, 0, 1)
        const fechaFin = new Date(selectedYear, 11, 31, 23, 59, 59, 999)
        const fechaInicioStr = fechaInicio.toISOString().split('T')[0]
        const fechaFinStr = fechaFin.toISOString().split('T')[0]

        // IMPORTANTE: Incluir aula_id de la asistencia para preservar el aula hist√≥rica
        // Tambi√©n incluir datos del estudiante para poder determinar estudiantes por mes
        const { data: todasAsistenciasData, error: todasAsistenciasError } = await supabase
          .from('asistencias')
          .select(`
            estudiante_id, 
            fecha, 
            estado,
            aula_id,
            aula:aulas(id, nombre),
            estudiante:estudiantes(id, aula_id)
          `)
          .eq('fcp_id', fcp.id)
          .gte('fecha', fechaInicioStr)
          .lte('fecha', fechaFinStr)

        if (todasAsistenciasError) throw todasAsistenciasError

        // Obtener estudiantes activos actuales de la FCP (para meses actuales/futuros)
        const { data: estudiantesActualesData, error: estudiantesError } = await supabase
          .from('estudiantes')
          .select('id, aula_id')
          .eq('fcp_id', fcp.id)
          .eq('activo', true)

        if (estudiantesError) throw estudiantesError

        if (todasAsistenciasError) throw todasAsistenciasError

        // Obtener asistencias "presente" para el c√°lculo
        const asistenciasPresente = todasAsistenciasData?.filter(a => a.estado === 'presente') || []

        const porcentajesPorMes: { [mes: number]: number } = {}

        // Determinar el mes actual para comparar
        const fechaActual = new Date()
        const mesActual = fechaActual.getMonth()
        const a√±oActual = fechaActual.getFullYear()

        // Para cada mes del a√±o
        for (let mes = 0; mes < 12; mes++) {
          // Determinar si este mes es anterior al actual
          const esMesAnterior = selectedYear < a√±oActual || (selectedYear === a√±oActual && mes < mesActual)

          let totalAsistenPromed = 0
          let totalOportunidadesAsistencia = 0

          // Obtener aulas seg√∫n el mes consultado
          let aulasParaMes: any[] = []

          if (esMesAnterior) {
            // Para meses anteriores, obtener aulas √∫nicas de las asistencias de ese mes espec√≠fico
            const mesInicio = new Date(selectedYear, mes, 1)
            const mesFin = new Date(selectedYear, mes + 1, 0)
            const mesInicioStr = mesInicio.toISOString().split('T')[0]
            const mesFinStr = mesFin.toISOString().split('T')[0]

            const asistenciasDelMes = todasAsistenciasData?.filter((a: any) => {
              const fechaAsistencia = new Date(a.fecha)
              return fechaAsistencia >= mesInicio && fechaAsistencia <= mesFin
            }) || []

            const aulasMap = new Map<string, any>()
            asistenciasDelMes.forEach((a: any) => {
              if (a.aula_id && a.aula && !aulasMap.has(a.aula_id)) {
                aulasMap.set(a.aula_id, {
                  id: a.aula_id,
                  nombre: a.aula.nombre || 'Sin aula'
                })
              }
            })
            aulasParaMes = Array.from(aulasMap.values())
          } else {
            // Para meses actuales/futuros, usar las aulas activas de la FCP
            aulasParaMes = aulasData || []
          }

          // Obtener estudiantes seg√∫n el mes consultado
          let estudiantesParaMes: any[] = []

          if (esMesAnterior) {
            // Para meses anteriores, obtener estudiantes √∫nicos de las asistencias de ese mes espec√≠fico
            const mesInicio = new Date(selectedYear, mes, 1)
            const mesFin = new Date(selectedYear, mes + 1, 0)
            const mesInicioStr = mesInicio.toISOString().split('T')[0]
            const mesFinStr = mesFin.toISOString().split('T')[0]

            const asistenciasDelMes = todasAsistenciasData?.filter((a: any) => {
              const fechaAsistencia = new Date(a.fecha)
              return fechaAsistencia >= mesInicio && fechaAsistencia <= mesFin
            }) || []

            const estudiantesMap = new Map<string, any>()
            asistenciasDelMes.forEach((asist: any) => {
              if (asist.estudiante && !estudiantesMap.has(asist.estudiante_id)) {
                estudiantesMap.set(asist.estudiante_id, {
                  id: asist.estudiante.id,
                  aula_id: asist.aula_id // Usar aula_id de la asistencia (hist√≥rica)
                })
              }
            })
            estudiantesParaMes = Array.from(estudiantesMap.values())
          } else {
            // Para meses actuales/futuros, usar estudiantes activos actuales
            estudiantesParaMes = estudiantesActualesData || []
          }

          // Procesar por aula usando aula_id de la asistencia
          aulasParaMes.forEach((aula) => {
            // IMPORTANTE: Agrupar estudiantes por aula seg√∫n el mes consultado
            // Para meses anteriores: usar aula_id de las asistencias (hist√≥rica)
            // Para meses actuales/futuros: usar aula_id actual del estudiante
            let estudiantesAula: any[] = []

            if (esMesAnterior) {
              // Para meses anteriores, filtrar asistencias que pertenecen a esta aula seg√∫n aula_id de la asistencia
              const mesInicio = new Date(selectedYear, mes, 1)
              const mesFin = new Date(selectedYear, mes + 1, 0)

              const asistenciasDeAula = todasAsistenciasData?.filter((a: any) => {
                const fechaAsistencia = new Date(a.fecha)
                return a.aula_id === aula.id && fechaAsistencia >= mesInicio && fechaAsistencia <= mesFin
              }) || []

              const estudiantesIdsEnAula = new Set(asistenciasDeAula.map((a: any) => a.estudiante_id))
              estudiantesAula = estudiantesParaMes?.filter(e => estudiantesIdsEnAula.has(e.id)) || []
            } else {
              // Para meses actuales/futuros, filtrar estudiantes por su aula_id actual
              estudiantesAula = estudiantesParaMes?.filter(e => e.aula_id === aula.id) || []
            }

            const registrados = estudiantesAula.length

            if (registrados === 0) return

            // IMPORTANTE: Filtrar asistencias de esta aula para este mes espec√≠fico
            const mesInicio = new Date(selectedYear, mes, 1)
            const mesFin = new Date(selectedYear, mes + 1, 0)

            const asistenciasDeAula = todasAsistenciasData?.filter((a: any) => {
              const fechaAsistencia = new Date(a.fecha)
              return a.aula_id === aula.id && fechaAsistencia >= mesInicio && fechaAsistencia <= mesFin
            }) || []

            // Detectar d√≠as completos para esta aula usando aula_id de la asistencia
            const estudiantesAulaIds = new Set(estudiantesAula.map(e => e.id))
            const asistenciasPorFecha = new Map<string, Set<string>>() // fecha -> Set<estudiante_id>

            asistenciasDeAula.forEach((asistencia: any) => {
              if (estudiantesAulaIds.has(asistencia.estudiante_id)) {
                const fecha = asistencia.fecha
                if (!asistenciasPorFecha.has(fecha)) {
                  asistenciasPorFecha.set(fecha, new Set())
                }
                asistenciasPorFecha.get(fecha)!.add(asistencia.estudiante_id)
              }
            })

            // Validar d√≠as completos y contar d√≠as de clases (igual que ReporteMensual)
            let diasDeClases = 0
            const fechasDiasCompletos = new Set<string>() // Guardar fechas de d√≠as completos
            
            asistenciasPorFecha.forEach((estudiantesMarcados, fecha) => {
              const marcados = estudiantesMarcados.size
              // Parsear fecha como fecha local para evitar problemas de zona horaria
              const [year, monthNum, day] = fecha.split('-').map(Number)
              const fechaDate = new Date(year, monthNum - 1, day)
              const esDelMes = fechaDate.getFullYear() === selectedYear && fechaDate.getMonth() === mes
              
              if (!esDelMes) return // Solo procesar fechas del mes actual
              
              // Para detectar d√≠as incompletos, usar TODOS los estudiantes del aula (como en la p√°gina de asistencias)
              // NO filtrar por created_at porque los estudiantes pueden haber sido agregados despu√©s
              const totalEstudiantesEnFecha = registrados
              
              // Solo contar d√≠as completos (todos los estudiantes de esta aula marcados) del mes correspondiente
              if (marcados === registrados && registrados > 0) {
                diasDeClases++
                fechasDiasCompletos.add(fecha)
              } else if (marcados > 0 && marcados < registrados && registrados > 0) {
                // D√≠a incompleto: hay algunos estudiantes marcados pero no todos los que deber√≠an tener asistencia
                console.log('‚ö†Ô∏è [ReporteParticipantesPorMes] D√≠a incompleto detectado:', {
                  fecha,
                  aula: aula.nombre,
                  marcados,
                  registrados,
                  fcp: fcp.nombre
                })
                
                diasIncompletosGlobales.push({
                  fecha,
                  fechaFormateada: fechaDate.toLocaleDateString('es-ES', { day: 'numeric', month: 'long' }),
                  nivel: aula.nombre,
                  aulaId: aula.id,
                  marcados,
                  total: registrados,
                })
              }
            })

            // Contar asistencias "presente" para estudiantes de esta aula SOLO de d√≠as completos
            // Usar aula_id de la asistencia para filtrar correctamente
            const asistenciasAula = asistenciasPresente?.filter((a: any) => {
              // Solo incluir asistencias que pertenecen a esta aula seg√∫n aula_id de la asistencia
              if (a.aula_id !== aula.id) return false
              if (!estudiantesAulaIds.has(a.estudiante_id)) return false
              const [year, monthNum, day] = a.fecha.split('-').map(Number)
              const fechaDate = new Date(year, monthNum - 1, day)
              const esDelMes = fechaDate.getFullYear() === selectedYear && fechaDate.getMonth() === mes
              // Solo contar asistencias de d√≠as completos
              return esDelMes && fechasDiasCompletos.has(a.fecha)
            }) || []
            const asistenPromed = asistenciasAula.length

            // Calcular oportunidades de asistencia para esta aula (igual que ReporteMensual)
            const oportunidadesAsistencia = diasDeClases * registrados
            
            // Acumular totales
            totalAsistenPromed += asistenPromed
            totalOportunidadesAsistencia += oportunidadesAsistencia
          })

          // Calcular porcentaje total de la FCP para este mes (igual que ReporteMensual)
          const porcentaje =
            totalOportunidadesAsistencia > 0
              ? (totalAsistenPromed / totalOportunidadesAsistencia) * 100
              : 0
          porcentajesPorMes[mes] = porcentaje

          // Acumular para total general por mes (si hay m√∫ltiples FCPs)
          if (!totalesPorMes[mes]) {
            totalesPorMes[mes] = { asistencias: 0, oportunidades: 0 }
          }
          totalesPorMes[mes].asistencias += totalAsistenPromed
          totalesPorMes[mes].oportunidades += totalOportunidadesAsistencia
        }

        // Usar directamente el n√∫mero de identificaci√≥n de la FCP
        const numeroIdentificacion = (fcp as any).numero_identificacion || fcp.id.substring(0, 6).toUpperCase() || 'FCP'

        fcps.push({
          codigo: numeroIdentificacion,
          nombre: fcp.razon_social || (fcp as any).numero_identificacion || 'FCP',
          porcentajesPorMes,
          numero_identificacion: (fcp as any).numero_identificacion,
          razon_social: fcp.razon_social,
        })
      }

      // Calcular porcentajes totales por mes
      const porcentajesTotalesPorMes: { [mes: number]: number } = {}
      for (let mes = 0; mes < 12; mes++) {
        const totalMes = totalesPorMes[mes]
        if (totalMes && totalMes.oportunidades > 0) {
          porcentajesTotalesPorMes[mes] =
            (totalMes.asistencias / totalMes.oportunidades) * 100
        } else {
          porcentajesTotalesPorMes[mes] = 0
        }
      }

      setReporteData({
        year: selectedYear,
        fcps,
        totalesPorMes: porcentajesTotalesPorMes,
        diasIncompletos: diasIncompletosGlobales.sort((a, b) => a.fecha.localeCompare(b.fecha)),
      })
      
      // Mostrar d√≠as incompletos de forma destacada en la consola
      console.log('')
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
      console.log('üìäüìäüìä RESUMEN DE D√çAS INCOMPLETOS (FCPs por Mes) üìäüìäüìä')
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
      console.log(`Total de d√≠as incompletos detectados: ${diasIncompletosGlobales.length}`)
      console.log('')
      
      if (diasIncompletosGlobales.length > 0) {
        console.log('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è LISTA DE D√çAS INCOMPLETOS ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è')
        console.log('')
        diasIncompletosGlobales.forEach((dia, index) => {
          const faltantes = dia.total - dia.marcados
          const porcentajeCompleto = ((dia.marcados / dia.total) * 100).toFixed(1)
          console.log(`${index + 1}. ${dia.fechaFormateada} - ${dia.nivel}`)
          console.log(`   üìÖ Fecha: ${dia.fecha}`)
          console.log(`   üë• Marcados: ${dia.marcados} / ${dia.total} estudiantes`)
          console.log(`   ‚ùå Faltantes: ${faltantes} estudiantes`)
          console.log(`   üìä Porcentaje completo: ${porcentajeCompleto}%`)
          console.log('')
        })
      } else {
        console.log('‚úÖ No se detectaron d√≠as incompletos')
        console.log('   (Todos los d√≠as tienen asistencia completa)')
        console.log('')
      }
      
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê')
      console.log('')
    } catch (error) {
      console.error('Error generating report:', error)
      toast.error('Error al generar el reporte', 'Intenta nuevamente.')
    } finally {
      setLoading(false)
    }
  }

  const exportarExcel = async () => {
    if (!reporteData) return

    try {
      const XLSX = await import('xlsx-js-style')

      const wb = XLSX.utils.book_new()

      const monthNames = [
        'ENERO',
        'FEBRERO',
        'MARZO',
        'ABRIL',
        'MAYO',
        'JUNIO',
        'JULIO',
        'AGOSTO',
        'SEPTIEMBRE',
        'OCTUBRE',
        'NOVIEMBRE',
        'DICIEMBRE',
      ]

      // Estilos
      // Estilos con colores del tema
      const headerStyle = getExcelHeaderStyle()
      const cellStyle = getExcelCellStyle()
      const totalStyle = getExcelTotalStyle()

      const applyStyle = (ws: any, range: string, style: any) => {
        const cellRange = XLSX.utils.decode_range(range)
        for (let R = cellRange.s.r; R <= cellRange.e.r; ++R) {
          for (let C = cellRange.s.c; C <= cellRange.e.c; ++C) {
            const cellAddress = XLSX.utils.encode_cell({ c: C, r: R })
            if (!ws[cellAddress]) ws[cellAddress] = { t: 's', v: '' }
            ws[cellAddress].s = style
          }
        }
      }

      // Preparar datos
      const header = ['C√≥digo', 'FCP', ...monthNames]
      const rows: any[] = reporteData.fcps.map((fcp) => [
        fcp.codigo,
        fcp.nombre,
        ...monthNames.map((_, index) =>
          fcp.porcentajesPorMes[index]
            ? fcp.porcentajesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ])

      // Fila de totales
      const totalRow = [
        'Total General',
        '',
        ...monthNames.map((_, index) =>
          reporteData.totalesPorMes[index]
            ? reporteData.totalesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ]

      const encabezado = [
        [`% de la asistencia por mes - ${reporteData.year}`],
        [`PROYECTO: TODAS LAS FCPs`, `A√ëO: ${reporteData.year}`, `MES: TODOS LOS MESES`],
        ...(responsable ? [[`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, `EMAIL: ${responsable.email.toUpperCase()}`, `ROL: ${responsable.rol.toUpperCase()}`]] : []),
        [],
        header,
        ...rows,
        totalRow,
      ]

      const ws = XLSX.utils.aoa_to_sheet(encabezado)

      // Aplicar estilos
      ws['A1'].s = {
        font: { bold: true, sz: 16 },
        alignment: { horizontal: 'center' },
      }

      const headerRowIndex = 4
      const headerRange = XLSX.utils.encode_range({
        s: { c: 0, r: headerRowIndex },
        e: { c: header.length - 1, r: headerRowIndex },
      })
      applyStyle(ws, headerRange, headerStyle)
      
      // Ajustar ancho de columnas
      ws['!cols'] = [
        { wch: 15 }, // C√≥digo
        { wch: 30 }, // FCP
        ...monthNames.map(() => ({ wch: 12 })), // Meses
      ]

      // Estilos para datos
      if (rows.length > 0) {
        const dataStartRow = headerRowIndex + 1
        const dataEndRow = headerRowIndex + rows.length
        const dataRange = XLSX.utils.encode_range({
          s: { c: 0, r: dataStartRow },
          e: { c: header.length - 1, r: dataEndRow },
        })
        applyStyle(ws, dataRange, cellStyle)
      }

      // Estilo para fila de totales
      const totalRowIndex = headerRowIndex + 1 + rows.length
      const totalRange = XLSX.utils.encode_range({
        s: { c: 0, r: totalRowIndex },
        e: { c: header.length - 1, r: totalRowIndex },
      })
      applyStyle(ws, totalRange, totalStyle)


      XLSX.utils.book_append_sheet(wb, ws, 'Reporte Participantes')

      const nombreArchivo = `Reporte_FCPs_por_Mes_${reporteData.year}.xlsx`
      XLSX.writeFile(wb, nombreArchivo)
    } catch (error) {
      console.error('Error exporting to Excel:', error)
      toast.error('Error al exportar a Excel', 'Intenta nuevamente.')
    }
  }

  const exportarPDF = async () => {
    if (!reporteData) return

    try {
      const jsPDF = (await import('jspdf')).default
      const autotableModule = await import('jspdf-autotable')

      let autoTable: any = null
      if (
        (autotableModule as any).autoTable &&
        typeof (autotableModule as any).autoTable === 'function'
      ) {
        autoTable = (autotableModule as any).autoTable
      } else if (
        (autotableModule as any).default &&
        typeof (autotableModule as any).default === 'function'
      ) {
        autoTable = (autotableModule as any).default
      }

      if (
        (autotableModule as any).applyPlugin &&
        typeof (autotableModule as any).applyPlugin === 'function'
      ) {
        ;(autotableModule as any).applyPlugin(jsPDF)
      }

      const doc = new jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' })
      const pageWidth = doc.internal.pageSize.getWidth()

      const monthNames = [
        'ENERO',
        'FEBRERO',
        'MARZO',
        'ABRIL',
        'MAYO',
        'JUNIO',
        'JULIO',
        'AGOSTO',
        'SEPTIEMBRE',
        'OCTUBRE',
        'NOVIEMBRE',
        'DICIEMBRE',
      ]

      let y = 12

      // T√≠tulo
      doc.setFontSize(12)
      doc.setFont('helvetica', 'bold')
      doc.text(
        `% de la asistencia por mes - ${reporteData.year}`,
        pageWidth / 2,
        y,
        { align: 'center' }
      )
      y += 4

      // Informaci√≥n del responsable (tres columnas)
      doc.setFontSize(8)
      doc.setFont('helvetica', 'normal')
      const col1 = 20
      const col2 = pageWidth / 3 + 10
      const col3 = (pageWidth / 3) * 2 + 10
      
      doc.text(`PROYECTO: TODAS LAS FCPs`, col1, y)
      doc.text(`A√ëO: ${reporteData.year}`, col2, y)
      doc.text(`MES: TODOS LOS MESES`, col3, y)
      y += 4
      if (responsable) {
        doc.text(`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, col1, y)
        doc.text(`EMAIL: ${responsable.email.toUpperCase()}`, col2, y)
        doc.text(`ROL: ${responsable.rol.toUpperCase()}`, col3, y)
        y += 4
      }
      y += 4

      // Preparar datos para la tabla
      const headers: string[] = ['C√≥digo', 'FCP', ...monthNames]
      const body: any[] = reporteData.fcps.map((fcp) => [
        fcp.codigo,
        fcp.nombre,
        ...monthNames.map((_, index) =>
          fcp.porcentajesPorMes[index]
            ? fcp.porcentajesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ])

      // Fila de totales
      const totalRow = [
        'Total General',
        '',
        ...monthNames.map((_, index) =>
          reporteData.totalesPorMes[index]
            ? reporteData.totalesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ]
      body.push(totalRow)

      const numCols = headers.length
      const availableWidth = getAvailableTableWidth(doc, 15)
      const fontSize = getFontSizeForColumns(numCols)
      const columnConfigs: PDFTableColumnConfig[] = [
        { type: 'compact', weight: 0.6, halign: 'left' },
        { type: 'text', weight: 1.2, halign: 'left' },
        ...monthNames.map(() => ({ type: 'compact' as const, weight: 0.5, halign: 'center' as const })),
      ]
      const columnStyles = getProportionalColumnStyles(numCols, availableWidth, columnConfigs)

      const tableOptions = {
        startY: y,
        head: [headers],
        body: body,
        theme: 'grid',
        tableWidth: availableWidth,
        margin: { left: 15, right: 15 },
        headStyles: {
          ...getPDFHeaderStyles(),
          fontSize,
          cellPadding: 2,
        },
        bodyStyles: {
          ...getPDFBodyStyles(),
          fontSize: Math.max(5, fontSize - 0.5),
          cellPadding: 1.5,
        },
        alternateRowStyles: getPDFAlternateRowStyles(),
        styles: {
          cellPadding: 1.5,
          overflow: 'linebreak',
          fontSize: Math.max(5, fontSize - 0.5),
        },
        columnStyles,
        didParseCell: function (data: any) {
          try {
            if (data.table && data.table.body) {
              const rowIndex = data.rowIndex
              if (rowIndex !== undefined && rowIndex >= 0) {
                const row = data.table.body[rowIndex]
                if (row && rowIndex === data.table.body.length - 1) {
                  data.cell.styles.fillColor = getPDFTotalRowColor()
                  data.cell.styles.fontStyle = 'bold'
                }
              }
            }
          } catch (e) {
            console.warn('Error en didParseCell:', e)
          }
        },
      }

      if (typeof (doc as any).autoTable === 'function') {
        ;(doc as any).autoTable(tableOptions)
      } else if (typeof autoTable === 'function') {
        autoTable(doc, tableOptions)
      } else {
        throw new Error(
          'autoTable no est√° disponible. Verifica la instalaci√≥n de jspdf-autotable.'
        )
      }

      const nombreArchivo = `Reporte_FCPs_por_Mes_${reporteData.year}.pdf`
      doc.save(nombreArchivo)
    } catch (error) {
      console.error('Error exporting to PDF:', error)
      toast.error('Error al exportar a PDF', 'Intenta nuevamente.')
    }
  }

  if (!selectedFCP && userFCPs.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <p className="text-muted-foreground mb-4">Cargando FCPs...</p>
        </CardContent>
      </Card>
    )
  }

  if (!roleLoading && !isFacilitador) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <p className="text-muted-foreground mb-4">
            No tienes permisos para ver este reporte. Solo los facilitadores pueden acceder a esta funcionalidad.
          </p>
        </CardContent>
      </Card>
    )
  }

  const monthNames = [
    'ENERO',
    'FEBRERO',
    'MARZO',
    'ABRIL',
    'MAYO',
    'JUNIO',
    'JULIO',
    'AGOSTO',
    'SEPTIEMBRE',
    'OCTUBRE',
    'NOVIEMBRE',
    'DICIEMBRE',
  ]

  return (
    <div>
      <Card className="mb-6">
        <CardHeader>
          <CardTitle>Configurar Reporte de FCPs por Mes</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {!fcpIdProp && !isFacilitador && (
              <div>
                <label className="text-sm font-medium mb-2 block">FCP:</label>
                <Select
                  value={selectedFCP || ''}
                  onValueChange={(value) => setSelectedFCP(value || null)}
                >
                  <SelectTrigger className="w-full">
                    <SelectValue placeholder="Seleccionar FCP">
                      {selectedFCP ? (
                        <div className="flex items-center gap-2">
                          <Building2 className="h-4 w-4" />
                          <span className="truncate">{userFCPs.find(fcp => fcp.id === selectedFCP)?.nombre || 'Seleccionar FCP'}</span>
                        </div>
                      ) : (
                        'Seleccionar FCP'
                      )}
                    </SelectValue>
                  </SelectTrigger>
                  <SelectContent>
                  {userFCPs.map((fcp) => (
                      <SelectItem key={fcp.id} value={fcp.id}>
                        <div className="flex items-center gap-2">
                          <Building2 className="h-4 w-4 flex-shrink-0" />
                          <span className="truncate">{fcp.nombre}</span>
                          {fcp.numero_identificacion && (
                            <span className="text-xs text-muted-foreground whitespace-nowrap">({fcp.numero_identificacion})</span>
                          )}
                        </div>
                      </SelectItem>
                  ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            <div>
              <label className="text-sm font-medium mb-2 block">A√±o:</label>
              <Input
                type="number"
                value={selectedYear}
                onChange={(e) => setSelectedYear(parseInt(e.target.value) || new Date().getFullYear())}
                className="w-full"
                min="2020"
                max="2100"
              />
            </div>
          </div>

          {isFacilitador && (
            <div className="mt-2 text-sm text-muted-foreground">
              <p>Como facilitador, el reporte incluir√° todas las FCPs del sistema.</p>
            </div>
          )}

          <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador']}>
            <div className="mt-4">
              <Button onClick={generarReporte} disabled={loading || (!isFacilitador && !selectedFCP)}>
                {loading ? (
                  <>
                    <Calendar className="mr-2 h-4 w-4 animate-pulse" />
                    Generando...
                  </>
                ) : (
                  <>
                    <Calendar className="mr-2 h-4 w-4" />
                    Generar Reporte
                  </>
                )}
              </Button>
            </div>
          </RoleGuard>
        </CardContent>
      </Card>

      {reporteData && (
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle>
                  % de la asistencia por mes - {reporteData.year}
                </CardTitle>
                {responsable && (
                  <div className="text-sm text-muted-foreground mt-1 grid grid-cols-3 gap-x-8 gap-y-1">
                    <p><strong>PROYECTO:</strong> TODAS LAS FCPs</p>
                    <p><strong>A√ëO:</strong> {reporteData.year}</p>
                    <p><strong>MES:</strong> TODOS LOS MESES</p>
                    {responsable && (
                      <>
                        <p><strong>RESPONSABLE:</strong> {responsable.nombre.toUpperCase()}</p>
                        <p><strong>EMAIL:</strong> {responsable.email.toUpperCase()}</p>
                        <p><strong>ROL:</strong> {responsable.rol.toUpperCase()}</p>
                      </>
                    )}
                  </div>
                )}
              </div>
              <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador']}>
                <div className="flex gap-2">
                  <Button variant="outline" onClick={exportarExcel}>
                    <FileSpreadsheet className="mr-2 h-4 w-4" />
                    Excel
                  </Button>
                  <Button variant="outline" onClick={exportarPDF}>
                    <FileText className="mr-2 h-4 w-4" />
                    PDF
                  </Button>
                </div>
              </RoleGuard>
            </div>
          </CardHeader>
          <CardContent>
            {/* Mensaje de d√≠as incompletos */}
            {reporteData.diasIncompletos && reporteData.diasIncompletos.length > 0 && (
              <div className="mb-4 rounded-md bg-warning/20 border border-warning/50 p-4">
                <h4 className="font-semibold text-warning-foreground mb-2">
                  ‚ö†Ô∏è D√≠as con asistencia incompleta
                </h4>
                <p className="text-sm text-warning-foreground mb-2">
                  Los siguientes d√≠as no se complet√≥ la asistencia de todos los estudiantes. Estos d√≠as <strong>no se incluyen</strong> en los totales del reporte:
                </p>
                <ul className="text-sm text-warning-foreground space-y-2">
                  {reporteData.diasIncompletos.map((dia, index) => {
                    // Parsear fecha como fecha local para evitar problemas de zona horaria
                    const [year, month, day] = dia.fecha.split('-').map(Number)
                    const fechaDate = new Date(year, month - 1, day)
                    const yearForUrl = fechaDate.getFullYear()
                    const monthForUrl = fechaDate.getMonth()
                    const asistenciasUrl = `/asistencias?aulaId=${dia.aulaId}&month=${monthForUrl}&year=${yearForUrl}`
                    
                    return (
                      <li key={`${dia.fecha}-${dia.nivel}-${index}`} className="flex items-center justify-between gap-3 p-2 rounded-md bg-warning/30 border border-warning/60">
                        <span className="flex-1">
                          ‚Ä¢ <strong>{dia.fechaFormateada}</strong> - Nivel: <strong>{dia.nivel}</strong> - Marcados: {dia.marcados}/{dia.total} estudiantes
                        </span>
                        <Button
                          type="button"
                          size="sm"
                          variant="outline"
                          onClick={() => router.push(asistenciasUrl)}
                          className="ml-auto text-blue-600 dark:text-blue-400 border-blue-300 dark:border-blue-700 hover:bg-blue-50 dark:hover:bg-blue-900/30 hover:text-blue-700 dark:hover:text-blue-300 whitespace-nowrap"
                        >
                          <Calendar className="h-4 w-4 mr-1.5" />
                          Corregir asistencia
                        </Button>
                      </li>
                    )
                  })}
                </ul>
              </div>
            )}
            
            <p className="mb-2 text-xs text-muted-foreground sm:hidden">Desliza para ver m√°s columnas ‚Üí</p>
            <div className="table-responsive overflow-x-auto">
              <table className="w-full border-collapse border border-border text-sm">
                <thead>
                  <tr className="bg-muted/50">
                    <th className="border border-border p-2 bg-muted/50 text-left text-foreground">
                      C√≥digo
                    </th>
                    <th className="border border-border p-2 bg-muted/50 text-left text-foreground">
                      FCP
                    </th>
                    {monthNames.map((mes) => (
                      <th
                        key={mes}
                        className="border border-border p-2 bg-muted/50 text-center text-foreground"
                      >
                        {mes}
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {reporteData.fcps.map((fcp, index) => (
                    <tr
                      key={fcp.codigo}
                      className={`border-b border-border ${index % 2 === 0 ? 'bg-background' : 'bg-muted/30'} hover:bg-accent/50`}
                    >
                      <td className="border border-border p-2 font-semibold text-foreground">
                        {fcp.codigo}
                      </td>
                      <td className="border border-border p-2 text-foreground">
                        {fcp.nombre}
                      </td>
                      {monthNames.map((_, mesIndex) => (
                        <td
                          key={mesIndex}
                          className="border border-border p-2 text-center text-foreground"
                        >
                          {fcp.porcentajesPorMes[mesIndex]
                            ? `${fcp.porcentajesPorMes[mesIndex].toFixed(2)}%`
                            : '-'}
                        </td>
                      ))}
                    </tr>
                  ))}
                  {/* Fila de totales */}
                  <tr className="bg-accent font-bold">
                    <td className="border border-border p-2 text-foreground" colSpan={2}>
                      Total General
                    </td>
                    {monthNames.map((_, mesIndex) => (
                      <td
                        key={mesIndex}
                        className="border border-border p-2 text-center text-foreground"
                      >
                        {reporteData.totalesPorMes[mesIndex]
                          ? `${reporteData.totalesPorMes[mesIndex].toFixed(2)}%`
                          : '-'}
                      </td>
                    ))}
                  </tr>
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}

