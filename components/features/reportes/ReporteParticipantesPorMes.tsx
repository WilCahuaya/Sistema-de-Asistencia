'use client'

import React, { useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { FileSpreadsheet, FileText, Calendar } from 'lucide-react'
import { useUserRole } from '@/hooks/useUserRole'
import { RoleGuard } from '@/components/auth/RoleGuard'
import { useSearchParams } from 'next/navigation'

interface ReporteParticipantesPorMesProps {
  fcpId: string | null
}

interface FCPData {
  codigo: string
  nombre: string
  porcentajesPorMes: { [mes: number]: number } // mes (0-11) -> porcentaje
  numero_identificacion?: string
  razon_social?: string
}

interface ReporteData {
  year: number
  fcps: FCPData[]
  totalesPorMes: { [mes: number]: number } // Porcentaje total por mes
}

export function ReporteParticipantesPorMes({ fcpId: fcpIdProp }: ReporteParticipantesPorMesProps) {
  const searchParams = useSearchParams()
  const autoGenerate = searchParams.get('auto') === 'true'
  
  const [loading, setLoading] = useState(false)
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear())
  const [selectedFCP, setSelectedFCP] = useState<string | null>(fcpIdProp || null)
  const [userFCPs, setUserFCPs] = useState<Array<{ id: string; nombre: string }>>([])
  const [reporteData, setReporteData] = useState<ReporteData | null>(null)
  const [autoGenerated, setAutoGenerated] = useState(false)
  const [responsable, setResponsable] = useState<{ nombre: string; email: string; rol: string } | null>(null)
  const { isFacilitador, loading: roleLoading } = useUserRole(selectedFCP)

  useEffect(() => {
    const initialize = async () => {
      if (fcpIdProp) {
        setSelectedFCP(fcpIdProp)
      } else {
        await loadUserFCPs()
      }
    }
    initialize()
  }, [fcpIdProp])

  // Generar reporte automáticamente solo cuando viene desde "Ver Detalles" (auto=true)
  useEffect(() => {
    if (autoGenerate && isFacilitador && !roleLoading && !autoGenerated && !loading && !reporteData) {
      // Pequeño delay para asegurar que todo esté listo
      const timer = setTimeout(() => {
        setAutoGenerated(true)
        generarReporte()
      }, 500)
      return () => clearTimeout(timer)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [autoGenerate, isFacilitador, roleLoading, autoGenerated, loading, reporteData])

  const loadUserFCPs = async () => {
    try {
      const supabase = createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return

      const { data, error } = await supabase
        .from('fcp_miembros')
        .select(`
          fcp_id,
          fcp:fcps(id, razon_social, numero_identificacion)
        `)
        .eq('usuario_id', user.id)
        .eq('activo', true)

      if (error) throw error

      const fcps = data
        ?.filter((item: any) => item.fcp !== null && item.fcp !== undefined)
        .map((item: any) => ({
          id: item.fcp.id,
          nombre: item.fcp.razon_social || item.fcp.numero_identificacion || 'FCP',
        })) || []

      setUserFCPs(fcps)
      if (fcps.length > 0 && !selectedFCP) {
        setSelectedFCP(fcps[0].id)
      }
    } catch (error) {
      console.error('Error loading FCPs:', error)
    }
  }

  const generarReporte = async () => {
    // Para facilitadores, no necesitamos selectedFCP ya que cargamos todas las FCPs
    if (!isFacilitador && !selectedFCP) {
      alert('Por favor, selecciona una FCP')
      return
    }

    try {
      setLoading(true)
      const supabase = createClient()

      // Obtener datos del usuario actual (responsable)
      const { data: { user } } = await supabase.auth.getUser()
      if (user) {
        if (isFacilitador) {
          // Para facilitadores, obtener su rol del sistema
          const { data: usuarioFcpData, error: usuarioFcpError } = await supabase
            .from('fcp_miembros')
            .select(`
              rol,
              usuario:usuarios(nombre_completo, email)
            `)
            .eq('usuario_id', user.id)
            .eq('rol', 'facilitador')
            .eq('activo', true)
            .limit(1)
            .single()

          if (!usuarioFcpError && usuarioFcpData) {
            const usuario = usuarioFcpData.usuario as any
            setResponsable({
              nombre: usuario?.nombre_completo || usuario?.email || user.email || '',
              email: usuario?.email || user.email || '',
              rol: 'Facilitador',
            })
          }
        } else if (selectedFCP) {
          // Obtener rol y datos del usuario en la FCP
          const { data: usuarioFcpData, error: usuarioFcpError } = await supabase
            .from('fcp_miembros')
            .select(`
              rol,
              usuario:usuarios(nombre_completo, email)
            `)
            .eq('usuario_id', user.id)
            .eq('fcp_id', selectedFCP)
            .eq('activo', true)
            .single()

          if (!usuarioFcpError && usuarioFcpData) {
            const usuario = usuarioFcpData.usuario as any
            const rol = usuarioFcpData.rol === 'facilitador' ? 'Facilitador' : usuarioFcpData.rol === 'director' ? 'Director' : usuarioFcpData.rol === 'secretario' ? 'Secretario' : usuarioFcpData.rol === 'tutor' ? 'Tutor' : ''
            if (rol) {
              setResponsable({
                nombre: usuario?.nombre_completo || usuario?.email || user.email || '',
                email: usuario?.email || user.email || '',
                rol,
              })
            }
          }
        }
      }

      // Si el usuario es facilitador, obtener TODAS las FCPs del sistema
      // Si no es facilitador, obtener solo las FCPs del usuario
      let fcpsAConsultar: Array<{ id: string; nombre: string; numero_identificacion?: string }> = []
      
      if (isFacilitador) {
        // Facilitadores pueden ver todas las FCPs del sistema
        const { data: todasLasFCPs, error: fcpsError } = await supabase
          .from('fcps')
          .select('id, razon_social, numero_identificacion')
          .eq('activa', true)
          .order('razon_social', { ascending: true })
        
        if (fcpsError) throw fcpsError
        fcpsAConsultar = (todasLasFCPs || []).map((fcp: any) => ({
          id: fcp.id,
          nombre: fcp.razon_social || fcp.numero_identificacion || 'FCP',
          numero_identificacion: fcp.numero_identificacion
        }))
      } else {
        // Usuarios no facilitadores solo ven sus FCPs
        if (fcpIdProp) {
          const { data: fcpData } = await supabase
            .from('fcps')
            .select('id, razon_social, numero_identificacion')
            .eq('id', fcpIdProp)
            .single()
          if (fcpData) {
            fcpsAConsultar = [{ id: fcpData.id, nombre: fcpData.razon_social || fcpData.numero_identificacion || 'FCP', numero_identificacion: fcpData.numero_identificacion }]
          }
        } else if (selectedFCP) {
          const { data: fcpData } = await supabase
            .from('fcps')
            .select('id, razon_social, numero_identificacion')
            .eq('id', selectedFCP)
            .single()
          if (fcpData) {
            fcpsAConsultar = [{ id: fcpData.id, nombre: fcpData.razon_social || fcpData.numero_identificacion || 'FCP', numero_identificacion: fcpData.numero_identificacion }]
          }
        } else {
          fcpsAConsultar = userFCPs.length > 0 ? userFCPs : []
        }
      }

      const fcps: FCPData[] = []
      const totalesPorMes: { [mes: number]: { asistencias: number; oportunidades: number } } = {}

      // Para cada FCP, calcular porcentaje total por mes (igual que ReporteMensual)
      for (const fcp of fcpsAConsultar) {
        // Obtener todas las aulas de la FCP
        const { data: aulasData, error: aulasError } = await supabase
          .from('aulas')
          .select('id, nombre')
          .eq('fcp_id', fcp.id)
          .eq('activa', true)

        if (aulasError) throw aulasError

        // Obtener todos los estudiantes activos de la FCP
        const { data: estudiantesData, error: estudiantesError } = await supabase
          .from('estudiantes')
          .select('id, aula_id')
          .eq('fcp_id', fcp.id)
          .eq('activo', true)

        if (estudiantesError) throw estudiantesError

        // Obtener TODAS las asistencias del año para esta FCP
        const fechaInicio = new Date(selectedYear, 0, 1)
        const fechaFin = new Date(selectedYear, 11, 31, 23, 59, 59, 999)
        const fechaInicioStr = fechaInicio.toISOString().split('T')[0]
        const fechaFinStr = fechaFin.toISOString().split('T')[0]

        const estudianteIds = estudiantesData?.map((e) => e.id) || []
        
        const { data: todasAsistenciasData, error: todasAsistenciasError } = await supabase
          .from('asistencias')
          .select('estudiante_id, fecha, estado')
          .eq('fcp_id', fcp.id)
          .in('estudiante_id', estudianteIds)
          .gte('fecha', fechaInicioStr)
          .lte('fecha', fechaFinStr)

        if (todasAsistenciasError) throw todasAsistenciasError

        // Obtener asistencias "presente" para el cálculo
        const asistenciasPresente = todasAsistenciasData?.filter(a => a.estado === 'presente') || []

        const porcentajesPorMes: { [mes: number]: number } = {}

        // Para cada mes del año
        for (let mes = 0; mes < 12; mes++) {
          let totalAsistenPromed = 0
          let totalOportunidadesAsistencia = 0

          // Procesar por aula (igual que ReporteMensual)
          aulasData?.forEach((aula) => {
            const estudiantesAula = estudiantesData?.filter(e => e.aula_id === aula.id) || []
            const registrados = estudiantesAula.length

            if (registrados === 0) return

            // Detectar días completos para esta aula (igual que ReporteMensual)
            const estudiantesAulaIds = new Set(estudiantesAula.map(e => e.id))
            const asistenciasPorFecha = new Map<string, Set<string>>() // fecha -> Set<estudiante_id>

            todasAsistenciasData?.forEach(asistencia => {
              if (estudiantesAulaIds.has(asistencia.estudiante_id)) {
                const fecha = asistencia.fecha
                if (!asistenciasPorFecha.has(fecha)) {
                  asistenciasPorFecha.set(fecha, new Set())
                }
                asistenciasPorFecha.get(fecha)!.add(asistencia.estudiante_id)
              }
            })

            // Validar días completos y contar días de clases (igual que ReporteMensual)
            let diasDeClases = 0
            const fechasDiasCompletos = new Set<string>() // Guardar fechas de días completos
            
            asistenciasPorFecha.forEach((estudiantesMarcados, fecha) => {
              const marcados = estudiantesMarcados.size
              // Parsear fecha como fecha local para evitar problemas de zona horaria
              const [year, monthNum, day] = fecha.split('-').map(Number)
              const fechaDate = new Date(year, monthNum - 1, day)
              const esDelMes = fechaDate.getFullYear() === selectedYear && fechaDate.getMonth() === mes
              
              // Solo contar días completos (todos los estudiantes de esta aula marcados) del mes correspondiente
              if (marcados === registrados && esDelMes) {
                diasDeClases++
                fechasDiasCompletos.add(fecha)
              }
            })

            // Contar asistencias "presente" para estudiantes de esta aula SOLO de días completos (igual que ReporteMensual)
            const asistenciasAula = asistenciasPresente?.filter(a => {
              if (!estudiantesAulaIds.has(a.estudiante_id)) return false
              const [year, monthNum, day] = a.fecha.split('-').map(Number)
              const fechaDate = new Date(year, monthNum - 1, day)
              const esDelMes = fechaDate.getFullYear() === selectedYear && fechaDate.getMonth() === mes
              // Solo contar asistencias de días completos
              return esDelMes && fechasDiasCompletos.has(a.fecha)
            }) || []
            const asistenPromed = asistenciasAula.length

            // Calcular oportunidades de asistencia para esta aula (igual que ReporteMensual)
            const oportunidadesAsistencia = diasDeClases * registrados
            
            // Acumular totales
            totalAsistenPromed += asistenPromed
            totalOportunidadesAsistencia += oportunidadesAsistencia
          })

          // Calcular porcentaje total de la FCP para este mes (igual que ReporteMensual)
          const porcentaje =
            totalOportunidadesAsistencia > 0
              ? (totalAsistenPromed / totalOportunidadesAsistencia) * 100
              : 0
          porcentajesPorMes[mes] = porcentaje

          // Acumular para total general por mes (si hay múltiples FCPs)
          if (!totalesPorMes[mes]) {
            totalesPorMes[mes] = { asistencias: 0, oportunidades: 0 }
          }
          totalesPorMes[mes].asistencias += totalAsistenPromed
          totalesPorMes[mes].oportunidades += totalOportunidadesAsistencia
        }

        // Usar directamente el número de identificación de la FCP
        const numeroIdentificacion = (fcp as any).numero_identificacion || fcp.id.substring(0, 6).toUpperCase() || 'FCP'

        fcps.push({
          codigo: numeroIdentificacion,
          nombre: fcp.razon_social || (fcp as any).numero_identificacion || 'FCP',
          porcentajesPorMes,
          numero_identificacion: (fcp as any).numero_identificacion,
          razon_social: fcp.razon_social,
        })
      }

      // Calcular porcentajes totales por mes
      const porcentajesTotalesPorMes: { [mes: number]: number } = {}
      for (let mes = 0; mes < 12; mes++) {
        const totalMes = totalesPorMes[mes]
        if (totalMes && totalMes.oportunidades > 0) {
          porcentajesTotalesPorMes[mes] =
            (totalMes.asistencias / totalMes.oportunidades) * 100
        } else {
          porcentajesTotalesPorMes[mes] = 0
        }
      }

      setReporteData({
        year: selectedYear,
        fcps,
        totalesPorMes: porcentajesTotalesPorMes,
      })
    } catch (error) {
      console.error('Error generating report:', error)
      alert('Error al generar el reporte. Por favor, intenta nuevamente.')
    } finally {
      setLoading(false)
    }
  }

  const exportarExcel = async () => {
    if (!reporteData) return

    try {
      const XLSX = await import('xlsx-js-style')

      const wb = XLSX.utils.book_new()

      const monthNames = [
        'ENERO',
        'FEBRERO',
        'MARZO',
        'ABRIL',
        'MAYO',
        'JUNIO',
        'JULIO',
        'AGOSTO',
        'SEPTIEMBRE',
        'OCTUBRE',
        'NOVIEMBRE',
        'DICIEMBRE',
      ]

      // Estilos
      const headerStyle = {
        font: { bold: true, color: { rgb: 'FFFFFF' }, sz: 11 },
        fill: { fgColor: { rgb: '4472C4' } },
        alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
        border: {
          top: { style: 'thin', color: { rgb: '000000' } },
          bottom: { style: 'thin', color: { rgb: '000000' } },
          left: { style: 'thin', color: { rgb: '000000' } },
          right: { style: 'thin', color: { rgb: '000000' } },
        },
      }

      const cellStyle = {
        border: {
          top: { style: 'thin', color: { rgb: '000000' } },
          bottom: { style: 'thin', color: { rgb: '000000' } },
          left: { style: 'thin', color: { rgb: '000000' } },
          right: { style: 'thin', color: { rgb: '000000' } },
        },
        alignment: { vertical: 'center' },
      }

      const totalStyle = {
        ...cellStyle,
        font: { bold: true },
        fill: { fgColor: { rgb: 'B4C6E7' } },
      }

      const applyStyle = (ws: any, range: string, style: any) => {
        const cellRange = XLSX.utils.decode_range(range)
        for (let R = cellRange.s.r; R <= cellRange.e.r; ++R) {
          for (let C = cellRange.s.c; C <= cellRange.e.c; ++C) {
            const cellAddress = XLSX.utils.encode_cell({ c: C, r: R })
            if (!ws[cellAddress]) ws[cellAddress] = { t: 's', v: '' }
            ws[cellAddress].s = style
          }
        }
      }

      // Preparar datos
      const header = ['Código', 'FCP', ...monthNames]
      const rows: any[] = reporteData.fcps.map((fcp) => [
        fcp.codigo,
        fcp.nombre,
        ...monthNames.map((_, index) =>
          fcp.porcentajesPorMes[index]
            ? fcp.porcentajesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ])

      // Fila de totales
      const totalRow = [
        'Total General',
        '',
        ...monthNames.map((_, index) =>
          reporteData.totalesPorMes[index]
            ? reporteData.totalesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ]

      const encabezado = [
        [`% de la asistencia por mes - ${reporteData.year}`],
        [`PROYECTO: TODAS LAS FCPs`, `AÑO: ${reporteData.year}`, `MES: TODOS LOS MESES`],
        ...(responsable ? [[`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, `EMAIL: ${responsable.email.toUpperCase()}`, `ROL: ${responsable.rol.toUpperCase()}`]] : []),
        [],
        header,
        ...rows,
        totalRow,
      ]

      const ws = XLSX.utils.aoa_to_sheet(encabezado)

      // Aplicar estilos
      ws['A1'].s = {
        font: { bold: true, sz: 16 },
        alignment: { horizontal: 'center' },
      }

      const headerRowIndex = 4
      const headerRange = XLSX.utils.encode_range({
        s: { c: 0, r: headerRowIndex },
        e: { c: header.length - 1, r: headerRowIndex },
      })
      applyStyle(ws, headerRange, headerStyle)
      
      // Ajustar ancho de columnas
      ws['!cols'] = [
        { wch: 15 }, // Código
        { wch: 30 }, // FCP
        ...monthNames.map(() => ({ wch: 12 })), // Meses
      ]

      // Estilos para datos
      if (rows.length > 0) {
        const dataStartRow = headerRowIndex + 1
        const dataEndRow = headerRowIndex + rows.length
        const dataRange = XLSX.utils.encode_range({
          s: { c: 0, r: dataStartRow },
          e: { c: header.length - 1, r: dataEndRow },
        })
        applyStyle(ws, dataRange, cellStyle)
      }

      // Estilo para fila de totales
      const totalRowIndex = headerRowIndex + 1 + rows.length
      const totalRange = XLSX.utils.encode_range({
        s: { c: 0, r: totalRowIndex },
        e: { c: header.length - 1, r: totalRowIndex },
      })
      applyStyle(ws, totalRange, totalStyle)


      XLSX.utils.book_append_sheet(wb, ws, 'Reporte Participantes')

      const nombreArchivo = `Reporte_FCPs_por_Mes_${reporteData.year}.xlsx`
      XLSX.writeFile(wb, nombreArchivo)
    } catch (error) {
      console.error('Error exporting to Excel:', error)
      alert('Error al exportar a Excel. Por favor, intenta nuevamente.')
    }
  }

  const exportarPDF = async () => {
    if (!reporteData) return

    try {
      const jsPDF = (await import('jspdf')).default
      const autotableModule = await import('jspdf-autotable')

      let autoTable: any = null
      if (
        (autotableModule as any).autoTable &&
        typeof (autotableModule as any).autoTable === 'function'
      ) {
        autoTable = (autotableModule as any).autoTable
      } else if (
        (autotableModule as any).default &&
        typeof (autotableModule as any).default === 'function'
      ) {
        autoTable = (autotableModule as any).default
      }

      if (
        (autotableModule as any).applyPlugin &&
        typeof (autotableModule as any).applyPlugin === 'function'
      ) {
        ;(autotableModule as any).applyPlugin(jsPDF)
      }

      const doc = new jsPDF('landscape')
      const pageWidth = doc.internal.pageSize.getWidth()

      const monthNames = [
        'ENERO',
        'FEBRERO',
        'MARZO',
        'ABRIL',
        'MAYO',
        'JUNIO',
        'JULIO',
        'AGOSTO',
        'SEPTIEMBRE',
        'OCTUBRE',
        'NOVIEMBRE',
        'DICIEMBRE',
      ]

      let y = 15

      // Título
      doc.setFontSize(16)
      doc.setFont('helvetica', 'bold')
      doc.text(
        `% de la asistencia por mes - ${reporteData.year}`,
        pageWidth / 2,
        y,
        { align: 'center' }
      )
      y += 8

      // Información del responsable (tres columnas)
      doc.setFontSize(10)
      doc.setFont('helvetica', 'normal')
      const col1 = 20
      const col2 = pageWidth / 3 + 10
      const col3 = (pageWidth / 3) * 2 + 10
      
      doc.text(`PROYECTO: TODAS LAS FCPs`, col1, y)
      doc.text(`AÑO: ${reporteData.year}`, col2, y)
      doc.text(`MES: TODOS LOS MESES`, col3, y)
      y += 6
      if (responsable) {
        doc.text(`RESPONSABLE: ${responsable.nombre.toUpperCase()}`, col1, y)
        doc.text(`EMAIL: ${responsable.email.toUpperCase()}`, col2, y)
        doc.text(`ROL: ${responsable.rol.toUpperCase()}`, col3, y)
        y += 6
      }
      y += 5

      // Preparar datos para la tabla
      const headers: string[] = ['Código', 'FCP', ...monthNames]
      const body: any[] = reporteData.fcps.map((fcp) => [
        fcp.codigo,
        fcp.nombre,
        ...monthNames.map((_, index) =>
          fcp.porcentajesPorMes[index]
            ? fcp.porcentajesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ])

      // Fila de totales
      const totalRow = [
        'Total General',
        '',
        ...monthNames.map((_, index) =>
          reporteData.totalesPorMes[index]
            ? reporteData.totalesPorMes[index].toFixed(2) + '%'
            : '-'
        ),
      ]
      body.push(totalRow)

      // Generar tabla
      const tableOptions = {
        startY: y,
        head: [headers],
        body: body,
        theme: 'grid',
        headStyles: {
          fillColor: [220, 220, 220],
          textColor: [0, 0, 0],
          fontStyle: 'bold',
          fontSize: 8,
          cellPadding: 2,
        },
        bodyStyles: {
          fontSize: 7,
          textColor: [0, 0, 0],
          cellPadding: 1.5,
        },
        alternateRowStyles: {
          fillColor: [250, 250, 250],
        },
        styles: {
          cellPadding: 1.5,
          overflow: 'linebreak',
          fontSize: 7,
        },
        columnStyles: {
          0: { cellWidth: 20 }, // Código
          1: { cellWidth: 40 }, // FCP
          ...Object.fromEntries(
            monthNames.map((_, idx) => [2 + idx, { cellWidth: 15, halign: 'center' }])
          ),
        },
        didParseCell: function (data: any) {
          try {
            if (data.table && data.table.body) {
              const rowIndex = data.rowIndex
              if (rowIndex !== undefined && rowIndex >= 0) {
                const row = data.table.body[rowIndex]
                if (row && rowIndex === data.table.body.length - 1) {
                  // Última fila (totales)
                  data.cell.styles.fillColor = [200, 200, 200] // Gris medio
                  data.cell.styles.fontStyle = 'bold'
                }
              }
            }
          } catch (e) {
            console.warn('Error en didParseCell:', e)
          }
        },
        margin: { top: y, left: 15, right: 15 },
      }

      if (typeof (doc as any).autoTable === 'function') {
        ;(doc as any).autoTable(tableOptions)
      } else if (typeof autoTable === 'function') {
        autoTable(doc, tableOptions)
      } else {
        throw new Error(
          'autoTable no está disponible. Verifica la instalación de jspdf-autotable.'
        )
      }

      const nombreArchivo = `Reporte_FCPs_por_Mes_${reporteData.year}.pdf`
      doc.save(nombreArchivo)
    } catch (error) {
      console.error('Error exporting to PDF:', error)
      alert('Error al exportar a PDF. Por favor, intenta nuevamente.')
    }
  }

  if (!selectedFCP && userFCPs.length === 0) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <p className="text-muted-foreground mb-4">Cargando FCPs...</p>
        </CardContent>
      </Card>
    )
  }

  if (!roleLoading && !isFacilitador) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <p className="text-muted-foreground mb-4">
            No tienes permisos para ver este reporte. Solo los facilitadores pueden acceder a esta funcionalidad.
          </p>
        </CardContent>
      </Card>
    )
  }

  const monthNames = [
    'ENERO',
    'FEBRERO',
    'MARZO',
    'ABRIL',
    'MAYO',
    'JUNIO',
    'JULIO',
    'AGOSTO',
    'SEPTIEMBRE',
    'OCTUBRE',
    'NOVIEMBRE',
    'DICIEMBRE',
  ]

  return (
    <div>
      <Card className="mb-6">
        <CardHeader>
          <CardTitle>Configurar Reporte de FCPs por Mes</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {!fcpIdProp && !isFacilitador && (
              <div>
                <label className="text-sm font-medium mb-2 block">FCP:</label>
                <select
                  value={selectedFCP || ''}
                  onChange={(e) => setSelectedFCP(e.target.value || null)}
                  className="w-full px-3 py-2 border border-gray-300 rounded-md dark:bg-gray-800 dark:border-gray-700 dark:text-white"
                >
                  {userFCPs.map((fcp) => (
                    <option key={fcp.id} value={fcp.id}>
                      {fcp.nombre}
                    </option>
                  ))}
                </select>
              </div>
            )}

            <div>
              <label className="text-sm font-medium mb-2 block">Año:</label>
              <Input
                type="number"
                value={selectedYear}
                onChange={(e) => setSelectedYear(parseInt(e.target.value) || new Date().getFullYear())}
                className="w-full"
                min="2020"
                max="2100"
              />
            </div>
          </div>

          {isFacilitador && (
            <div className="mt-2 text-sm text-muted-foreground">
              <p>Como facilitador, el reporte incluirá todas las FCPs del sistema.</p>
            </div>
          )}

          <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador']}>
            <div className="mt-4">
              <Button onClick={generarReporte} disabled={loading || (!isFacilitador && !selectedFCP)}>
                {loading ? (
                  <>
                    <Calendar className="mr-2 h-4 w-4 animate-pulse" />
                    Generando...
                  </>
                ) : (
                  <>
                    <Calendar className="mr-2 h-4 w-4" />
                    Generar Reporte
                  </>
                )}
              </Button>
            </div>
          </RoleGuard>
        </CardContent>
      </Card>

      {reporteData && (
        <Card>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div>
                <CardTitle>
                  % de la asistencia por mes - {reporteData.year}
                </CardTitle>
                {responsable && (
                  <div className="text-sm text-muted-foreground mt-1 grid grid-cols-3 gap-x-8 gap-y-1">
                    <p><strong>PROYECTO:</strong> TODAS LAS FCPs</p>
                    <p><strong>AÑO:</strong> {reporteData.year}</p>
                    <p><strong>MES:</strong> TODOS LOS MESES</p>
                    {responsable && (
                      <>
                        <p><strong>RESPONSABLE:</strong> {responsable.nombre.toUpperCase()}</p>
                        <p><strong>EMAIL:</strong> {responsable.email.toUpperCase()}</p>
                        <p><strong>ROL:</strong> {responsable.rol.toUpperCase()}</p>
                      </>
                    )}
                  </div>
                )}
              </div>
              <RoleGuard fcpId={selectedFCP} allowedRoles={['facilitador']}>
                <div className="flex gap-2">
                  <Button variant="outline" onClick={exportarExcel}>
                    <FileSpreadsheet className="mr-2 h-4 w-4" />
                    Excel
                  </Button>
                  <Button variant="outline" onClick={exportarPDF}>
                    <FileText className="mr-2 h-4 w-4" />
                    PDF
                  </Button>
                </div>
              </RoleGuard>
            </div>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full border-collapse border border-gray-300 text-sm">
                <thead>
                  <tr>
                    <th className="border border-gray-300 p-2 bg-gray-100 dark:bg-gray-800 text-left">
                      Código
                    </th>
                    <th className="border border-gray-300 p-2 bg-gray-100 dark:bg-gray-800 text-left">
                      FCP
                    </th>
                    {monthNames.map((mes) => (
                      <th
                        key={mes}
                        className="border border-gray-300 p-2 bg-gray-100 dark:bg-gray-800 text-center"
                      >
                        {mes}
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {reporteData.fcps.map((fcp, index) => (
                    <tr
                      key={fcp.codigo}
                      className={
                        index % 2 === 0
                          ? 'bg-white dark:bg-gray-900'
                          : 'bg-gray-50 dark:bg-gray-800'
                      }
                    >
                      <td className="border border-gray-300 p-2 font-semibold">
                        {fcp.codigo}
                      </td>
                      <td className="border border-gray-300 p-2">
                        {fcp.nombre}
                      </td>
                      {monthNames.map((_, mesIndex) => (
                        <td
                          key={mesIndex}
                          className="border border-gray-300 p-2 text-center"
                        >
                          {fcp.porcentajesPorMes[mesIndex]
                            ? `${fcp.porcentajesPorMes[mesIndex].toFixed(2)}%`
                            : '-'}
                        </td>
                      ))}
                    </tr>
                  ))}
                  {/* Fila de totales */}
                  <tr className="bg-blue-100 dark:bg-blue-900 font-bold">
                    <td className="border border-gray-300 p-2" colSpan={2}>
                      Total General
                    </td>
                    {monthNames.map((_, mesIndex) => (
                      <td
                        key={mesIndex}
                        className="border border-gray-300 p-2 text-center"
                      >
                        {reporteData.totalesPorMes[mesIndex]
                          ? `${reporteData.totalesPorMes[mesIndex].toFixed(2)}%`
                          : '-'}
                      </td>
                    ))}
                  </tr>
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}

